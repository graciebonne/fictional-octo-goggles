(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,714768,172702,92687,753586,401855,713023,984345,177558,152634,e=>{"use strict";e.s([],714768),e.s(["HyperliquidError",()=>t,"TransportError",()=>i],172702);class t extends Error{constructor(e,t){super(e,t),this.name="HyperliquidError"}}class i extends t{constructor(e,t){super(e,t),this.name="TransportError"}}e.s(["HttpTransport",()=>c],92687);var r,n=e.i(868275);let o={withResolvers:Promise.withResolvers?()=>Promise.withResolvers():()=>{let e,t;return{promise:new Promise((i,r)=>(e=i,t=r)),resolve:e,reject:t}}},s={any:AbortSignal.any?e=>AbortSignal.any(e):e=>{let t=new AbortController;for(let i of e){if(i.aborted){t.abort(i.reason);break}i.addEventListener("abort",()=>t.abort(i.reason),{once:!0,signal:t.signal})}return t.signal},timeout:AbortSignal.timeout?e=>AbortSignal.timeout(e):e=>{let t=new AbortController;return setTimeout(()=>t.abort(new DOMException("Signal timed out.","TimeoutError")),e),t.signal}},a=globalThis.CustomEvent||class extends Event{constructor(e,t){var i;super(e,t),(0,n._)(this,"detail",void 0),this.detail=null!=(i=null==t?void 0:t.detail)?i:null}};class p extends i{constructor(e,t){let i,{response:r,body:o}=null!=e?e:{};r?(i="".concat(r.status," ").concat(r.statusText).trim(),o&&(i+=" - ".concat(o))):i="Unknown HTTP request error: ".concat(null==t?void 0:t.cause),super(i,t),(0,n._)(this,"response",void 0),(0,n._)(this,"body",void 0),this.name="HttpRequestError",this.response=r,this.body=o}}class c{async request(e,t,r){try{var n;let i=new URL(e,"explorer"===e?this.rpcUrl:this.apiUrl),o=this._mergeRequestInit({body:JSON.stringify(t),headers:{"Accept-Encoding":"gzip, deflate, br, zstd","Content-Type":"application/json"},keepalive:!0,method:"POST",signal:this.timeout?s.timeout(this.timeout):void 0},this.fetchOptions,{signal:r}),a=await fetch(i,o);if(!a.ok||!(null==(n=a.headers.get("Content-Type"))?void 0:n.includes("application/json"))){let e=await a.text().catch(()=>void 0);throw new p({response:a,body:e})}let c=await a.json();if((null==c?void 0:c.type)==="error")throw new p({response:a,body:null==c?void 0:c.message});return c}catch(e){if(e instanceof i)throw e;throw new p(void 0,{cause:e})}}_mergeHeadersInit(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];let r=new Headers;for(let e of t)for(let[t,i]of Symbol.iterator in e?e:Object.entries(e))r.set(t,i);return r}_mergeRequestInit(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];let r={},n=[],o=[];for(let e of t)Object.assign(r,e),e.headers&&n.push(e.headers),e.signal&&o.push(e.signal);return n.length>0&&(r.headers=this._mergeHeadersInit(...n)),o.length>0&&(r.signal=o.length>1?s.any(o):o[0]),r}constructor(e){var t,i,r,o;(0,n._)(this,"isTestnet",void 0),(0,n._)(this,"timeout",void 0),(0,n._)(this,"apiUrl",void 0),(0,n._)(this,"rpcUrl",void 0),(0,n._)(this,"fetchOptions",void 0),this.isTestnet=null!=(t=null==e?void 0:e.isTestnet)&&t,this.timeout=(null==e?void 0:e.timeout)===void 0?1e4:e.timeout,this.apiUrl=null!=(i=null==e?void 0:e.apiUrl)?i:this.isTestnet?"https://api.hyperliquid-testnet.xyz":"https://api.hyperliquid.xyz",this.rpcUrl=null!=(r=null==e?void 0:e.rpcUrl)?r:this.isTestnet?"https://rpc.hyperliquid-testnet.xyz":"https://rpc.hyperliquid.xyz",this.fetchOptions=null!=(o=null==e?void 0:e.fetchOptions)?o:{}}}e.s(["MAINNET_API_WS_URL",()=>E,"MAINNET_RPC_WS_URL",()=>S,"TESTNET_API_WS_URL",()=>I,"TESTNET_RPC_WS_URL",()=>U,"WebSocketTransport",()=>T],401855);class l extends Error{constructor(e,t){super("Error when reconnecting WebSocket: ".concat(e)),(0,n._)(this,"code",void 0),this.name="ReconnectingWebSocketError",this.cause=t,this.code=e}}class d{get isTerminated(){return this._abortController.signal.aborted}get terminationReason(){return this._abortController.signal.reason}get terminationSignal(){return this._abortController.signal}_createSocket(){let e="function"==typeof this._urlProvider?this._urlProvider():this._urlProvider,t="function"==typeof this._protocolsProvider?this._protocolsProvider():this._protocolsProvider;this._socket=function(e,t){let i=e();if(null===t)return i;let r=()=>{i.removeEventListener("close",n),i.removeEventListener("error",o),a.removeEventListener("abort",s)},n=()=>{i.removeEventListener("open",r),i.removeEventListener("error",o),a.removeEventListener("abort",s)},o=()=>{i.removeEventListener("open",r),i.removeEventListener("close",n),a.removeEventListener("abort",s)},s=()=>{i.close(3008,"Timeout")},a=AbortSignal.timeout(t);return i.addEventListener("open",r,{once:!0,signal:a}),i.addEventListener("close",n,{once:!0,signal:a}),i.addEventListener("error",o,{once:!0,signal:a}),a.addEventListener("abort",s,{once:!0}),i}(()=>new this.reconnectOptions.WebSocket(e,t),this.reconnectOptions.connectionTimeout)}_initInternalListeners(){let e=()=>{this._socket.removeEventListener("error",t),this._close()},t=()=>{this._socket.removeEventListener("close",e),this._close()};this._socket.addEventListener("open",this._open,{once:!0}),this._socket.addEventListener("close",e,{once:!0}),this._socket.addEventListener("error",t,{once:!0})}_cleanup(e,t){let i=new l(e,t);this._abortController.abort(i),this._socket.close(),this.dispatchEvent(new CustomEvent("terminate",{detail:i}))}get url(){return this._socket.url}get readyState(){return this._socket.readyState}get bufferedAmount(){return this._socket.bufferedAmount}get extensions(){return this._socket.extensions}get protocol(){return this._socket.protocol}get binaryType(){return this._socket.binaryType}set binaryType(e){this._socket.binaryType=e}get onclose(){return this._socket.onclose}set onclose(e){this._socket.onclose=e}get onerror(){return this._socket.onerror}set onerror(e){this._socket.onerror=e}get onmessage(){return this._socket.onmessage}set onmessage(e){this._socket.onmessage=e}get onopen(){return this._socket.onopen}set onopen(e){this._socket.onopen=e}close(e,t){let i=!(arguments.length>2)||void 0===arguments[2]||arguments[2];this._socket.close(e,t),i&&this._cleanup("TERMINATED_BY_USER")}send(e){this._socket.readyState===d.OPEN||this._abortController.signal.aborted?this._socket.send(e):this._messageBuffer.push(e)}addEventListener(e,t,i){let r;if(this._abortController.signal.aborted)r=t;else{let n=this._listeners.findIndex(r=>u(r,{type:e,listener:t,options:i}));-1!==n?r=this._listeners[n].listenerProxy:(r=r=>{try{"function"==typeof t?t.call(this,r):t.handleEvent(r)}finally{if("object"==typeof i&&!0===i.once){let r=this._listeners.findIndex(r=>u(r,{type:e,listener:t,options:i}));-1!==r&&this._listeners.splice(r,1)}}},this._listeners.push({type:e,listener:t,options:i,listenerProxy:r}))}this._socket.addEventListener(e,r,i)}removeEventListener(e,t,i){let r=this._listeners.findIndex(r=>u(r,{type:e,listener:t,options:i}));if(-1!==r){let{listenerProxy:t}=this._listeners[r];this._socket.removeEventListener(e,t,i),this._listeners.splice(r,1)}else this._socket.removeEventListener(e,t,i)}dispatchEvent(e){return this._socket.dispatchEvent(e)}constructor(e,t,i){var r,o,s;(0,n._)(this,"_socket",void 0),(0,n._)(this,"_urlProvider",void 0),(0,n._)(this,"_protocolsProvider",void 0),(0,n._)(this,"_listeners",[]),(0,n._)(this,"_attempt",0),(0,n._)(this,"_messageBuffer",[]),(0,n._)(this,"_abortController",new AbortController),(0,n._)(this,"reconnectOptions",void 0),(0,n._)(this,"_open",()=>{this._attempt=0,this._messageBuffer.forEach(e=>{this._socket.send(e)}),this._messageBuffer=[]}),(0,n._)(this,"_close",async()=>{try{if(this._abortController.signal.aborted)return;if(++this._attempt>this.reconnectOptions.maxRetries)return void this._cleanup("RECONNECTION_LIMIT");let e="number"==typeof this.reconnectOptions.reconnectionDelay?this.reconnectOptions.reconnectionDelay:this.reconnectOptions.reconnectionDelay(this._attempt);await function(e,t){return(null==t?void 0:t.aborted)?Promise.reject(t.reason):new Promise((i,r)=>{let n=()=>{clearTimeout(o),r(null==t?void 0:t.reason)},o=setTimeout(()=>{null==t||t.removeEventListener("abort",n),i()},e);null==t||t.addEventListener("abort",n,{once:!0})})}(e,this._abortController.signal);let{onclose:t,onerror:i,onmessage:r,onopen:n,binaryType:o}=this._socket;this._createSocket(),this._initInternalListeners(),this._listeners.forEach(e=>{let{type:t,listenerProxy:i,options:r}=e;this._socket.addEventListener(t,i,r)}),this._socket.onclose=t,this._socket.onerror=i,this._socket.onmessage=r,this._socket.onopen=n,this._socket.binaryType=o}catch(e){this._cleanup("UNKNOWN_ERROR",e)}}),(0,n._)(this,"CONNECTING",0),(0,n._)(this,"OPEN",1),(0,n._)(this,"CLOSING",2),(0,n._)(this,"CLOSED",3);let a="string"==typeof t||"function"==typeof t||Array.isArray(t)?t:void 0,p="object"!=typeof t||Array.isArray(t)?i:t;if(!globalThis.WebSocket&&!(null==p?void 0:p.WebSocket))throw Error("No WebSocket implementation found. Please provide a custom WebSocket constructor in the options.");this._urlProvider=e,this._protocolsProvider=a,this.reconnectOptions={WebSocket:null!=(r=null==p?void 0:p.WebSocket)?r:WebSocket,maxRetries:null!=(o=null==p?void 0:p.maxRetries)?o:3,connectionTimeout:(null==p?void 0:p.connectionTimeout)===void 0?1e4:p.connectionTimeout,reconnectionDelay:null!=(s=null==p?void 0:p.reconnectionDelay)?s:e=>Math.min(150*~~(1<<e),1e4)},this._createSocket(),this._initInternalListeners()}}function u(e,t){let i="object"==typeof e.options?e.options.capture:e.options,r="object"==typeof t.options?t.options.capture:t.options;return e.type===t.type&&e.listener===t.listener&&!!i==!!r}(0,n._)(d,"CONNECTING",0),(0,n._)(d,"OPEN",1),(0,n._)(d,"CLOSING",2),(0,n._)(d,"CLOSED",3);var f=e.i(235483);let h=f.looseObject({blockTime:f.unknown(),hash:f.unknown(),height:f.unknown(),numTxs:f.unknown(),proposer:f.unknown()}),g=f.looseObject({action:f.unknown(),block:f.unknown(),error:f.unknown(),hash:f.unknown(),time:f.unknown(),user:f.unknown()}),b=f.object({channel:f.string(),data:f.unknown()}),y=f.object({channel:f.literal("pong")}),m=f.pipe(f.array(h),f.minLength(1)),v=f.pipe(f.array(g),f.minLength(1));class w extends EventTarget{constructor(e){super(),e.addEventListener("message",e=>{try{let t=JSON.parse(e.data);f.is(b,t)?this.dispatchEvent(new a(t.channel,{detail:t.data})):f.is(y,t)?this.dispatchEvent(new a("pong",{detail:void 0})):f.is(m,t)?this.dispatchEvent(new a("_explorerBlock",{detail:t})):f.is(v,t)&&this.dispatchEvent(new a("_explorerTxs",{detail:t}))}catch(e){}})}}e.s(["WebSocketAsyncRequest",()=>A,"WebSocketRequestError",()=>x],753586);class x extends i{constructor(e,t){super(e,t),this.name="WebSocketRequestError"}}class A{async request(e,t,i){let r,n,s=t instanceof AbortSignal?void 0:t,a=t instanceof AbortSignal?t:i;if(null==a?void 0:a.aborted)return Promise.reject(a.reason);if(this.socket.terminationSignal.aborted)return Promise.reject(this.socket.terminationSignal.reason);"post"===e?n={method:e,id:r=++this.lastId,request:s}:"ping"===e?(r="ping",n={method:e}):(n={method:e,subscription:s},r=A.requestToId(n)),this.socket.send(JSON.stringify(n));let{promise:p,resolve:c,reject:l}=o.withResolvers();this.queue.push({id:r,resolve:c,reject:l});let d=()=>l(null==a?void 0:a.reason);return null==a||a.addEventListener("abort",d,{once:!0}),await p.finally(()=>{let e=this.queue.findIndex(e=>e.id===r);-1!==e&&this.queue.splice(e,1),null==a||a.removeEventListener("abort",d)})}static requestToId(e){return JSON.stringify(function e(t){if("string"==typeof t&&/^0[xX][0-9a-fA-F]+$/.test(t))return t.toLowerCase();if(Array.isArray(t))return t.map(e);if("object"==typeof t&&null!==t){let i={};for(let r in t)i[r]=e(t[r]);return i}return t}(function e(t){if(Array.isArray(t))return t.map(e);if("object"==typeof t&&null!==t){let i={};for(let r of Object.keys(t).sort())i[r]=e(t[r]);return i}return t}(e)))}constructor(e,t){(0,n._)(this,"socket",void 0),(0,n._)(this,"lastId",0),(0,n._)(this,"queue",[]),this.socket=e,t.addEventListener("subscriptionResponse",e=>{var t;null==(t=this.queue.find(t=>"string"==typeof t.id&&function e(t,i){if("string"==typeof t&&"string"==typeof i){let e=/^0x[0-9a-f]+$/i;return e.test(t)&&e.test(i)?t.toLowerCase()===i.toLowerCase():t===i}return"object"!=typeof t||"object"!=typeof i||null===t||null===i?t===i:Array.isArray(t)?Array.isArray(i)&&t.length===i.length&&t.every((t,r)=>e(t,i[r])):Object.keys(t).every(r=>r in i&&e(t[r],i[r]))}(JSON.parse(t.id),e.detail)))||t.resolve(e.detail)}),t.addEventListener("post",e=>{var t,i;if("error"===e.detail.response.type){null==(i=this.queue.find(t=>t.id===e.detail.id))||i.reject(new x(e.detail.response.payload));return}let r="info"===e.detail.response.type?e.detail.response.payload.data:e.detail.response.payload;null==(t=this.queue.find(t=>t.id===e.detail.id))||t.resolve(r)}),t.addEventListener("pong",()=>{var e;null==(e=this.queue.find(e=>"ping"===e.id))||e.resolve()}),t.addEventListener("error",e=>{try{var t,i,r,n,o,s,a;let p=e.detail.match(/id=(\d+)$/);if(p){let t=parseInt(p[1],10);null==(r=this.queue.find(e=>e.id===t))||r.reject(new x(e.detail));return}let c=null==(t=e.detail.match(/{.*}/))?void 0:t[0];if(!c)return;let l=JSON.parse(c);if("id"in l&&"number"==typeof l.id){null==(n=this.queue.find(e=>e.id===l.id))||n.reject(new x(e.detail));return}if("subscription"in l&&"object"==typeof l.subscription&&null!==l.subscription){let t=A.requestToId(l);null==(o=this.queue.find(e=>e.id===t))||o.reject(new x(e.detail));return}if(e.detail.startsWith("Already subscribed")||e.detail.startsWith("Invalid subscription")){let t=A.requestToId({method:"subscribe",subscription:l});null==(s=this.queue.find(e=>e.id===t))||s.reject(new x(e.detail));return}if(e.detail.startsWith("Already unsubscribed")){let t=A.requestToId({method:"unsubscribe",subscription:l});null==(a=this.queue.find(e=>e.id===t))||a.reject(new x(e.detail));return}let d=A.requestToId(l);null==(i=this.queue.find(e=>e.id===d))||i.reject(new x(e.detail))}catch(e){}});let i=()=>{this.queue.forEach(e=>{let{reject:t}=e;t(new x("WebSocket connection closed."))}),this.queue=[]};e.addEventListener("close",i),e.addEventListener("error",i)}}class _{async subscribe(e,t,i){let r=A.requestToId(t),n=this._subscriptions.get(r);if(!n){if(this._subscriptions.size>=1e3)throw new x("Cannot subscribe to more than 1000 channels.");if(this._hasUserParam(t)&&this._countUniqueUserSubscriptions()>=10)throw new x("Cannot track more than 10 unique users.");let e=this._wsRequester.request("subscribe",t).finally(()=>n.promiseFinished=!0);n={listeners:new Map,promise:e,promiseFinished:!1,failureController:new AbortController},this._subscriptions.set(r,n)}let o=n.listeners.get(i);return o||(o=async()=>{this._hlEvents.removeEventListener(e,i);let n=this._subscriptions.get(r);null==n||n.listeners.delete(i),(null==n?void 0:n.listeners.size)===0&&(this._subscriptions.delete(r),1===this._socket.readyState&&await this._wsRequester.request("unsubscribe",t))},this._hlEvents.addEventListener(e,i),n.listeners.set(i,o)),await n.promise,{unsubscribe:o,failureSignal:n.failureController.signal}}_handleOpen(){if(this.resubscribe)for(let[e,t]of this._subscriptions.entries())t.promiseFinished&&(t.promise=this._wsRequester.request("subscribe",JSON.parse(e)).catch(e=>t.failureController.abort(e)).finally(()=>t.promiseFinished=!0),t.promiseFinished=!1)}_handleClose(){if(!this.resubscribe||this._socket.terminationSignal.aborted)for(let e of this._subscriptions.values())for(let[t,i]of e.listeners)i()}_hasUserParam(e){return"object"==typeof e&&null!==e&&"user"in e}_countUniqueUserSubscriptions(){let e=new Set;for(let t of this._subscriptions.keys())try{let i=JSON.parse(t);this._hasUserParam(i)&&e.add(i.user)}catch(e){}return e.size}constructor(e,t,i,r){(0,n._)(this,"resubscribe",void 0),(0,n._)(this,"_socket",void 0),(0,n._)(this,"_wsRequester",void 0),(0,n._)(this,"_hlEvents",void 0),(0,n._)(this,"_subscriptions",new Map),this._socket=e,this._wsRequester=t,this._hlEvents=i,this.resubscribe=r,e.addEventListener("open",()=>this._handleOpen()),e.addEventListener("close",()=>this._handleClose()),e.addEventListener("error",()=>this._handleClose())}}let E="wss://api.hyperliquid.xyz/ws",I="wss://api.hyperliquid-testnet.xyz/ws",S="wss://rpc.hyperliquid.xyz/ws",U="wss://rpc.hyperliquid-testnet.xyz/ws";class T{get resubscribe(){return this._subscriptionManager.resubscribe}set resubscribe(e){this._subscriptionManager.resubscribe=e}_initKeepAlive(){let e=()=>{this._keepAliveInterval||(this._keepAliveInterval=setInterval(()=>{this.socket.send('{"method":"ping"}')},3e4))},t=()=>{clearInterval(this._keepAliveInterval),this._keepAliveInterval=void 0};this.socket.addEventListener("open",e),this.socket.addEventListener("close",t),this.socket.addEventListener("error",t)}async request(e,t,r){let n=this.timeout?s.timeout(this.timeout):void 0,o=r&&n?s.any([r,n]):null!=r?r:n;return await this._wsRequester.request("post",{type:"exchange"===e?"action":e,payload:t},o).catch(e=>{if(e instanceof i)throw e;throw new x("Unknown error while making a WebSocket request: ".concat(e),{cause:e})})}subscribe(e,t,i){return this._subscriptionManager.subscribe(e,t,i)}ready(e){return new Promise((t,i)=>{let r=e?s.any([this.socket.terminationSignal,e]):this.socket.terminationSignal;if(r.aborted)return i(new x("Failed to establish WebSocket connection",{cause:r.reason}));if(this.socket.readyState===d.OPEN)return t();let n=()=>{r.removeEventListener("abort",o),t()},o=()=>(this.socket.removeEventListener("open",n),i(new x("Failed to establish WebSocket connection",{cause:r.reason})));this.socket.addEventListener("open",n,{once:!0}),r.addEventListener("abort",o,{once:!0})})}close(e){return new Promise((t,i)=>{if(null==e?void 0:e.aborted)return i(new x("Failed to close WebSocket connection",{cause:e.reason}));if(this.socket.readyState===d.CLOSED)return t();let r=()=>{null==e||e.removeEventListener("abort",n),t()},n=()=>i(new x("Failed to close WebSocket connection",{cause:null==e?void 0:e.reason}));this.socket.addEventListener("close",r,{once:!0,signal:e}),this.socket.addEventListener("error",r,{once:!0,signal:e}),null==e||e.addEventListener("abort",n,{once:!0}),this.socket.close()})}constructor(e){var t,i,r;(0,n._)(this,"isTestnet",void 0),(0,n._)(this,"timeout",void 0),(0,n._)(this,"socket",void 0),(0,n._)(this,"_wsRequester",void 0),(0,n._)(this,"_hlEvents",void 0),(0,n._)(this,"_subscriptionManager",void 0),(0,n._)(this,"_keepAliveInterval",void 0),this.isTestnet=null!=(t=null==e?void 0:e.isTestnet)&&t,this.timeout=(null==e?void 0:e.timeout)===void 0?1e4:e.timeout,this.socket=new d(null!=(i=null==e?void 0:e.url)?i:this.isTestnet?I:E,null==e?void 0:e.reconnect),this._hlEvents=new w(this.socket),this._wsRequester=new A(this.socket,this._hlEvents),this._subscriptionManager=new _(this.socket,this._wsRequester,this._hlEvents,null==(r=null==e?void 0:e.resubscribe)||r),this._initKeepAlive()}}e.s(["ExchangeClient",()=>nT],984345);var k=e.i(448146);f.pipe(f.object({status:f.pipe(f.literal("err"),f.description("Error status.")),response:f.pipe(f.string(),f.description("Error message."))}),f.description("Error response for failed operations.")),f.pipe(f.object({status:f.pipe(f.literal("ok"),f.description("Successful status.")),response:f.pipe(f.object({type:f.pipe(f.literal("default"),f.description("Type of response."))}),f.description("Response details."))}),f.description("Successful response without specific data."));let j=f.pipe(f.object({r:f.pipe(f.pipe(k.Hex,f.length(66)),f.description("First 32-byte component.")),s:f.pipe(f.pipe(k.Hex,f.length(66)),f.description("Second 32-byte component.")),v:f.pipe(f.picklist([27,28]),f.description("Recovery identifier."))}),f.description("ECDSA signature components.")),D=f.pipe(k.UnsignedInteger,f.description("Nonce (timestamp in ms) used to prevent replay attacks.")),C=f.pipe(k.Hex,f.description("Chain ID in hex format for EIP-712 signing.")),B=f.pipe(f.picklist(["Mainnet","Testnet"]),f.description("HyperLiquid network type.")),O=BigInt(0x100000000-1),R=BigInt(32);function q(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=e.length,r=new Uint32Array(i),n=new Uint32Array(i);for(let o=0;o<i;o++){let{h:i,l:s}=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t?{h:Number(e&O),l:Number(e>>R&O)}:{h:0|Number(e>>R&O),l:0|Number(e&O)}}(e[o],t);[r[o],n[o]]=[i,s]}return[r,n]}function L(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function P(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if(!Number.isSafeInteger(e)||e<0)throw Error("".concat(t&&'"'.concat(t,'" '),"expected integer >= 0, got ").concat(e))}function M(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r=L(e),n=null==e?void 0:e.length,o=void 0!==t;if(!r||o&&n!==t){let s=r?"length=".concat(n):"type=".concat(typeof e);throw Error((i&&'"'.concat(i,'" '))+"expected Uint8Array"+(o?" of length ".concat(t):"")+", got "+s)}return e}function N(e){if("function"!=typeof e||"function"!=typeof e.create)throw Error("Hash must wrapped by utils.createHasher");P(e.outputLen),P(e.blockLen)}function F(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];if(e.destroyed)throw Error("Hash instance has been destroyed");if(t&&e.finished)throw Error("Hash#digest() has already been called")}function V(e,t){M(e,void 0,"digestInto() output");let i=t.outputLen;if(e.length<i)throw Error('"digestInto() output" expected to be of length >='+i)}function H(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];for(let e=0;e<t.length;e++)t[e].fill(0)}function z(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function W(e,t){return e<<32-t|e>>>t}let K=68===new Uint8Array(new Uint32Array([0x11223344]).buffer)[0]?e=>e:function(e){for(let i=0;i<e.length;i++){var t;e[i]=(t=e[i])<<24&0xff000000|t<<8&0xff0000|t>>>8&65280|t>>>24&255}return e},Z="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,G=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function X(e){if(M(e),Z)return e.toHex();let t="";for(let i=0;i<e.length;i++)t+=G[e[i]];return t}let Y={_0:48,_9:57,A:65,F:70,a:97,f:102};function J(e){return e>=Y._0&&e<=Y._9?e-Y._0:e>=Y.A&&e<=Y.F?e-(Y.A-10):e>=Y.a&&e<=Y.f?e-(Y.a-10):void 0}function Q(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);if(Z)return Uint8Array.fromHex(e);let t=e.length,i=t/2;if(t%2)throw Error("hex string expected, got unpadded hex of length "+t);let r=new Uint8Array(i);for(let t=0,n=0;t<i;t++,n+=2){let i=J(e.charCodeAt(n)),o=J(e.charCodeAt(n+1));if(void 0===i||void 0===o)throw Error('hex string expected, got non-hex character "'+(e[n]+e[n+1])+'" at index '+n);r[t]=16*i+o}return r}function $(e){if("string"!=typeof e)throw Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function ee(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];let r=0;for(let e=0;e<t.length;e++){let i=t[e];M(i),r+=i.length}let n=new Uint8Array(r);for(let e=0,i=0;e<t.length;e++){let r=t[e];n.set(r,i),i+=r.length}return n}function et(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=(t,i)=>e(i).update(t).digest(),r=e(void 0);return i.outputLen=r.outputLen,i.blockLen=r.blockLen,i.create=t=>e(t),Object.assign(i,t),Object.freeze(i)}function ei(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:32,t="object"==typeof globalThis?globalThis.crypto:null;if("function"!=typeof(null==t?void 0:t.getRandomValues))throw Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}let er=BigInt(0),en=BigInt(1),eo=BigInt(2),es=BigInt(7),ea=BigInt(256),ep=BigInt(113),ec=[],el=[],ed=[];for(let e=0,t=en,i=1,r=0;e<24;e++){[i,r]=[r,(2*i+3*r)%5],ec.push(2*(5*r+i)),el.push((e+1)*(e+2)/2%64);let n=er;for(let e=0;e<7;e++)(t=(t<<en^(t>>es)*ep)%ea)&eo&&(n^=en<<(en<<BigInt(e))-en);ed.push(n)}let eu=q(ed,!0),ef=eu[0],eh=eu[1],eg=(e,t,i)=>i>32?((e,t,i)=>t<<i-32|e>>>64-i)(e,t,i):((e,t,i)=>e<<i|t>>>32-i)(e,t,i),eb=(e,t,i)=>i>32?((e,t,i)=>e<<i-32|t>>>64-i)(e,t,i):((e,t,i)=>t<<i|e>>>32-i)(e,t,i);class ey{clone(){return this._cloneInto()}keccak(){K(this.state32),function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:24,i=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let t=0;t<10;t++)i[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){let r=(t+8)%10,n=(t+2)%10,o=i[n],s=i[n+1],a=eg(o,s,1)^i[r],p=eb(o,s,1)^i[r+1];for(let i=0;i<50;i+=10)e[t+i]^=a,e[t+i+1]^=p}let t=e[2],n=e[3];for(let i=0;i<24;i++){let r=el[i],o=eg(t,n,r),s=eb(t,n,r),a=ec[i];t=e[a],n=e[a+1],e[a]=o,e[a+1]=s}for(let t=0;t<50;t+=10){for(let r=0;r<10;r++)i[r]=e[t+r];for(let r=0;r<10;r++)e[t+r]^=~i[(r+2)%10]&i[(r+4)%10]}e[0]^=ef[r],e[1]^=eh[r]}H(i)}(this.state32,this.rounds),K(this.state32),this.posOut=0,this.pos=0}update(e){F(this),M(e);let{blockLen:t,state:i}=this,r=e.length;for(let n=0;n<r;){let o=Math.min(t-this.pos,r-n);for(let t=0;t<o;t++)i[this.pos++]^=e[n++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:e,suffix:t,pos:i,blockLen:r}=this;e[i]^=t,(128&t)!=0&&i===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){F(this,!1),M(e),this.finish();let t=this.state,{blockLen:i}=this;for(let r=0,n=e.length;r<n;){this.posOut>=i&&this.keccak();let o=Math.min(i-this.posOut,n-r);e.set(t.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return e}xofInto(e){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return P(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(V(e,this),this.finished)throw Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,H(this.state)}_cloneInto(e){let{blockLen:t,suffix:i,outputLen:r,rounds:n,enableXOF:o}=this;return e||(e=new ey(t,i,r,o,n)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=n,e.suffix=i,e.outputLen=r,e.enableXOF=o,e.destroyed=this.destroyed,e}constructor(e,t,i,r=!1,o=24){if((0,n._)(this,"state",void 0),(0,n._)(this,"pos",0),(0,n._)(this,"posOut",0),(0,n._)(this,"finished",!1),(0,n._)(this,"state32",void 0),(0,n._)(this,"destroyed",!1),(0,n._)(this,"blockLen",void 0),(0,n._)(this,"suffix",void 0),(0,n._)(this,"outputLen",void 0),(0,n._)(this,"enableXOF",!1),(0,n._)(this,"rounds",void 0),this.blockLen=e,this.suffix=t,this.outputLen=i,this.enableXOF=r,this.rounds=o,P(i,"outputLen"),!(0<e&&e<200))throw Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=function(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}(this.state)}}let em=function(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return et(()=>new ey(t,e,i),r)}(1,136,32);new TextDecoder;let ev=new TextEncoder;function ew(e){let t=new DataView(new ArrayBuffer(9));return t.setFloat64(1,e),t.setUint8(0,203),new Uint8Array(t.buffer)}let ex=f.object({signTypedData:f.pipe(f.function(),f.check(e=>3===e.length)),getAddress:f.function(),provider:f.nullish(f.object({getNetwork:f.function()}))}),eA=f.object({_signTypedData:f.pipe(f.function(),f.check(e=>3===e.length)),getAddress:f.function(),provider:f.nullish(f.object({getNetwork:f.function()}))}),e_=f.object({signTypedData:f.pipe(f.function(),f.check(e=>1===e.length||2===e.length)),getAddresses:f.function(),getChainId:f.function()}),eE=f.object({signTypedData:f.pipe(f.function(),f.check(e=>1===e.length||2===e.length)),address:f.string()});class eI extends t{constructor(e,t){super(e,t),this.name="AbstractWalletError"}}async function eS(e){let t,{wallet:i,domain:r,types:n,primaryType:o,message:s}=e;if(f.is(e_,i)||f.is(eE,i))try{t=await i.signTypedData({domain:r,types:{EIP712Domain:[{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"}],...n},primaryType:o,message:s})}catch(e){throw new eI("Failed to sign typed data with viem wallet. See cause for details.",{cause:e})}else if(f.is(ex,i))try{t=await i.signTypedData(r,n,s)}catch(e){throw new eI("Failed to sign typed data with ethers v6 wallet. See cause for details.",{cause:e})}else if(f.is(eA,i))try{t=await i._signTypedData(r,n,s)}catch(e){throw new eI("Failed to sign typed data with ethers v5 wallet. See cause for details.",{cause:e})}else throw new eI("Failed to sign typed data: unknown wallet");var a=t;return{r:"0x".concat(a.slice(2,66)),s:"0x".concat(a.slice(66,130)),v:parseInt(a.slice(130,132),16)}}async function eU(e){if(f.is(e_,e))try{let t=await e.getChainId();return"0x".concat(t.toString(16))}catch(e){throw new eI("Failed to get chain ID from viem wallet. See cause for details.",{cause:e})}if(f.is(ex,e)&&"provider"in e&&e.provider)try{let t=await e.provider.getNetwork();return"0x".concat(t.chainId.toString(16))}catch(e){throw new eI("Failed to get chain ID from ethers v6 wallet. See cause for details.",{cause:e})}if(f.is(eA,e)&&"provider"in e&&e.provider)try{let t=await e.provider.getNetwork();return"0x".concat(t.chainId.toString(16))}catch(e){throw new eI("Failed to get chain ID from ethers v5 wallet. See cause for details.",{cause:e})}return"0x1"}async function eT(e){if(f.is(e_,e))try{return(await e.getAddresses())[0].toLowerCase()}catch(e){throw new eI("Failed to get address from viem wallet. See cause for details.",{cause:e})}if(f.is(eE,e))return e.address.toLowerCase();if(f.is(ex,e)||f.is(eA,e))try{return(await e.getAddress()).toLowerCase()}catch(e){throw new eI("Failed to get address from ethers wallet. See cause for details.",{cause:e})}throw new eI("Failed to get wallet address: unknown wallet")}var ek=e.i(376054),ej=e.i(136927),eD=e.i(550475);class eC{update(e){F(this),M(e);let{view:t,buffer:i,blockLen:r}=this,n=e.length;for(let o=0;o<n;){let s=Math.min(r-this.pos,n-o);if(s===r){let t=z(e);for(;r<=n-o;o+=r)this.process(t,o);continue}i.set(e.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===r&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){F(this),V(e,this),this.finished=!0;let{buffer:t,view:i,blockLen:r,isLE:n}=this,{pos:o}=this;t[o++]=128,H(this.buffer.subarray(o)),this.padOffset>r-o&&(this.process(i,0),o=0);for(let e=o;e<r;e++)t[e]=0;i.setBigUint64(r-8,BigInt(8*this.length),n),this.process(i,0);let s=z(e),a=this.outputLen;if(a%4)throw Error("_sha2: outputLen must be aligned to 32bit");let p=a/4,c=this.get();if(p>c.length)throw Error("_sha2: outputLen bigger than state");for(let e=0;e<p;e++)s.setUint32(4*e,c[e],n)}digest(){let{buffer:e,outputLen:t}=this;this.digestInto(e);let i=e.slice(0,t);return this.destroy(),i}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());let{blockLen:t,buffer:i,length:r,finished:n,destroyed:o,pos:s}=this;return e.destroyed=o,e.finished=n,e.length=r,e.pos=s,r%t&&e.buffer.set(i),e}clone(){return this._cloneInto()}constructor(e,t,i,r){(0,n._)(this,"blockLen",void 0),(0,n._)(this,"outputLen",void 0),(0,n._)(this,"padOffset",void 0),(0,n._)(this,"isLE",void 0),(0,n._)(this,"buffer",void 0),(0,n._)(this,"view",void 0),(0,n._)(this,"finished",!1),(0,n._)(this,"length",0),(0,n._)(this,"pos",0),(0,n._)(this,"destroyed",!1),this.blockLen=e,this.outputLen=t,this.padOffset=i,this.isLE=r,this.buffer=new Uint8Array(e),this.view=z(this.buffer)}}let eB=Uint32Array.from([0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19]),eO=Uint32Array.from([0xc1059ed8,0x367cd507,0x3070dd17,0xf70e5939,0xffc00b31,0x68581511,0x64f98fa7,0xbefa4fa4]),eR=Uint32Array.from([0xcbbb9d5d,0xc1059ed8,0x629a292a,0x367cd507,0x9159015a,0x3070dd17,0x152fecd8,0xf70e5939,0x67332667,0xffc00b31,0x8eb44a87,0x68581511,0xdb0c2e0d,0x64f98fa7,0x47b5481d,0xbefa4fa4]),eq=Uint32Array.from([0x6a09e667,0xf3bcc908,0xbb67ae85,0x84caa73b,0x3c6ef372,0xfe94f82b,0xa54ff53a,0x5f1d36f1,0x510e527f,0xade682d1,0x9b05688c,0x2b3e6c1f,0x1f83d9ab,0xfb41bd6b,0x5be0cd19,0x137e2179]),eL=Uint32Array.from([0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0xfc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x6ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2]),eP=new Uint32Array(64);class eM extends eC{get(){let{A:e,B:t,C:i,D:r,E:n,F:o,G:s,H:a}=this;return[e,t,i,r,n,o,s,a]}set(e,t,i,r,n,o,s,a){this.A=0|e,this.B=0|t,this.C=0|i,this.D=0|r,this.E=0|n,this.F=0|o,this.G=0|s,this.H=0|a}process(e,t){for(let i=0;i<16;i++,t+=4)eP[i]=e.getUint32(t,!1);for(let e=16;e<64;e++){let t=eP[e-15],i=eP[e-2],r=W(t,7)^W(t,18)^t>>>3,n=W(i,17)^W(i,19)^i>>>10;eP[e]=n+eP[e-7]+r+eP[e-16]|0}let{A:i,B:r,C:n,D:o,E:s,F:a,G:p,H:c}=this;for(let e=0;e<64;e++){var l,d,u,f;let t=c+(W(s,6)^W(s,11)^W(s,25))+((l=s)&a^~l&p)+eL[e]+eP[e]|0,h=(W(i,2)^W(i,13)^W(i,22))+((d=i)&(u=r)^d&(f=n)^u&f)|0;c=p,p=a,a=s,s=o+t|0,o=n,n=r,r=i,i=t+h|0}i=i+this.A|0,r=r+this.B|0,n=n+this.C|0,o=o+this.D|0,s=s+this.E|0,a=a+this.F|0,p=p+this.G|0,c=c+this.H|0,this.set(i,r,n,o,s,a,p,c)}roundClean(){H(eP)}destroy(){this.set(0,0,0,0,0,0,0,0),H(this.buffer)}constructor(e){super(64,e,8,!1)}}class eN extends eM{constructor(){super(32),(0,n._)(this,"A",0|eB[0]),(0,n._)(this,"B",0|eB[1]),(0,n._)(this,"C",0|eB[2]),(0,n._)(this,"D",0|eB[3]),(0,n._)(this,"E",0|eB[4]),(0,n._)(this,"F",0|eB[5]),(0,n._)(this,"G",0|eB[6]),(0,n._)(this,"H",0|eB[7])}}let eF=q(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),eV=eF[0],eH=eF[1],ez=new Uint32Array(80),eW=new Uint32Array(80),eK=et(()=>new eN,{oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,1])}),eZ=BigInt(0),eG=BigInt(1);function eX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if("boolean"!=typeof e)throw Error((t&&'"'.concat(t,'" '))+"expected boolean, got type="+typeof e);return e}function eY(e){if("bigint"==typeof e){if(!e3(e))throw Error("positive bigint expected, got "+e)}else P(e);return e}function eJ(e){let t=eY(e).toString(16);return 1&t.length?"0"+t:t}function eQ(e){if("string"!=typeof e)throw Error("hex string expected, got "+typeof e);return""===e?eZ:BigInt("0x"+e)}function e$(e){return eQ(X(e))}function e0(e){var t;return eQ(X((t=M(e),Uint8Array.from(t)).reverse()))}function e1(e,t){P(t);let i=Q((e=eY(e)).toString(16).padStart(2*t,"0"));if(i.length!==t)throw Error("number too large");return i}function e2(e,t){return e1(e,t).reverse()}function e8(e){return Uint8Array.from(e,(t,i)=>{let r=t.charCodeAt(0);if(1!==t.length||r>127)throw Error('string contains non-ASCII character "'.concat(e[i],'" with code ').concat(r," at position ").concat(i));return r})}let e3=e=>"bigint"==typeof e&&eZ<=e,e6=e=>(eG<<BigInt(e))-eG;function e4(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!e||"object"!=typeof e)throw Error("expected valid options object");let r=(t,i)=>Object.entries(t).forEach(t=>{let[r,n]=t,o=e[r];if(i&&void 0===o)return;let s=typeof o;if(s!==n||null===o)throw Error('param "'.concat(r,'" is invalid: expected ').concat(n,", got ").concat(s))});r(t,!1),r(i,!0)}function e5(e){let t=new WeakMap;return function(i){for(var r=arguments.length,n=Array(r>1?r-1:0),o=1;o<r;o++)n[o-1]=arguments[o];let s=t.get(i);if(void 0!==s)return s;let a=e(i,...n);return t.set(i,a),a}}let e7=BigInt(0),e9=BigInt(1),te=BigInt(2),tt=BigInt(3),ti=BigInt(4),tr=BigInt(5),tn=BigInt(7),to=BigInt(8),ts=BigInt(9),ta=BigInt(16);function tp(e,t){let i=e%t;return i>=e7?i:t+i}function tc(e,t,i){let r=e;for(;t-- >e7;)r*=r,r%=i;return r}function tl(e,t){if(e===e7)throw Error("invert: expected non-zero number");if(t<=e7)throw Error("invert: expected positive modulus, got "+t);let i=tp(e,t),r=t,n=e7,o=e9,s=e9,a=e7;for(;i!==e7;){let e=r/i,t=r%i,p=n-s*e,c=o-a*e;r=i,i=t,n=s,o=a,s=p,a=c}if(r!==e9)throw Error("invert: does not exist");return tp(n,t)}function td(e,t,i){if(!e.eql(e.sqr(t),i))throw Error("Cannot find square root")}function tu(e,t){let i=(e.ORDER+e9)/ti,r=e.pow(t,i);return td(e,r,t),r}function tf(e,t){let i=(e.ORDER-tr)/to,r=e.mul(t,te),n=e.pow(r,i),o=e.mul(t,n),s=e.mul(e.mul(o,te),n),a=e.mul(o,e.sub(s,e.ONE));return td(e,a,t),a}function th(e){if(e<tt)throw Error("sqrt is not defined for small field");let t=e-e9,i=0;for(;t%te===e7;)t/=te,i++;let r=te,n=tw(e);for(;1===tm(n,r);)if(r++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===i)return tu;let o=n.pow(r,t),s=(t+e9)/te;return function(e,r){if(e.is0(r))return r;if(1!==tm(e,r))throw Error("Cannot find square root");let n=i,a=e.mul(e.ONE,o),p=e.pow(r,t),c=e.pow(r,s);for(;!e.eql(p,e.ONE);){if(e.is0(p))return e.ZERO;let t=1,i=e.sqr(p);for(;!e.eql(i,e.ONE);)if(t++,i=e.sqr(i),t===n)throw Error("Cannot find square root");let r=e9<<BigInt(n-t-1),o=e.pow(a,r);n=t,a=e.sqr(o),p=e.mul(p,a),c=e.mul(c,o)}return c}}let tg=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function tb(e){return e4(e,tg.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",BYTES:"number",BITS:"number"})),e}function ty(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Array(t.length).fill(i?e.ZERO:void 0),n=t.reduce((t,i,n)=>e.is0(i)?t:(r[n]=t,e.mul(t,i)),e.ONE),o=e.inv(n);return t.reduceRight((t,i,n)=>e.is0(i)?t:(r[n]=e.mul(t,r[n]),e.mul(t,i)),o),r}function tm(e,t){let i=(e.ORDER-e9)/te,r=e.pow(t,i),n=e.eql(r,e.ONE),o=e.eql(r,e.ZERO),s=e.eql(r,e.neg(e.ONE));if(!n&&!o&&!s)throw Error("invalid Legendre symbol result");return n?1:o?0:-1}class tv{create(e){return tp(e,this.ORDER)}isValid(e){if("bigint"!=typeof e)throw Error("invalid field element: expected bigint, got "+typeof e);return e7<=e&&e<this.ORDER}is0(e){return e===e7}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&e9)===e9}neg(e){return tp(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return tp(e*e,this.ORDER)}add(e,t){return tp(e+t,this.ORDER)}sub(e,t){return tp(e-t,this.ORDER)}mul(e,t){return tp(e*t,this.ORDER)}pow(e,t){var i=t;if(i<e7)throw Error("invalid exponent, negatives unsupported");if(i===e7)return this.ONE;if(i===e9)return e;let r=this.ONE,n=e;for(;i>e7;)i&e9&&(r=this.mul(r,n)),n=this.sqr(n),i>>=e9;return r}div(e,t){return tp(e*tl(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return tl(e,this.ORDER)}sqrt(e){var t;return this._sqrt||(this._sqrt=(t=this.ORDER)%ti===tt?tu:t%to===tr?tf:t%ta===ts?function(e){let t=tw(e),i=th(e),r=i(t,t.neg(t.ONE)),n=i(t,r),o=i(t,t.neg(r)),s=(e+tn)/ta;return(e,t)=>{let i=e.pow(t,s),a=e.mul(i,r),p=e.mul(i,n),c=e.mul(i,o),l=e.eql(e.sqr(a),t),d=e.eql(e.sqr(p),t);i=e.cmov(i,a,l),a=e.cmov(c,p,d);let u=e.eql(e.sqr(a),t),f=e.cmov(i,a,u);return td(e,f,t),f}}(t):th(t)),this._sqrt(this,e)}toBytes(e){return this.isLE?e2(e,this.BYTES):e1(e,this.BYTES)}fromBytes(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];M(e);let{_lengths:i,BYTES:r,isLE:n,ORDER:o,_mod:s}=this;if(i){if(!i.includes(e.length)||e.length>r)throw Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);let t=new Uint8Array(r);t.set(e,n?0:t.length-e.length),e=t}if(e.length!==r)throw Error("Field.fromBytes: expected "+r+" bytes, got "+e.length);let a=n?e0(e):e$(e);if(s&&(a=tp(a,o)),!t&&!this.isValid(a))throw Error("invalid field element: outside of range 0..ORDER");return a}invertBatch(e){return ty(this,e)}cmov(e,t,i){return i?t:e}constructor(e,t={}){let i;if((0,n._)(this,"ORDER",void 0),(0,n._)(this,"BITS",void 0),(0,n._)(this,"BYTES",void 0),(0,n._)(this,"isLE",void 0),(0,n._)(this,"ZERO",e7),(0,n._)(this,"ONE",e9),(0,n._)(this,"_lengths",void 0),(0,n._)(this,"_sqrt",void 0),(0,n._)(this,"_mod",void 0),e<=e7)throw Error("invalid field: expected ORDER > 0, got "+e);if(this.isLE=!1,null!=t&&"object"==typeof t){var r;"number"==typeof t.BITS&&(i=t.BITS),"function"==typeof t.sqrt&&(this.sqrt=t.sqrt),"boolean"==typeof t.isLE&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=null==(r=t.allowedLengths)?void 0:r.slice()),"boolean"==typeof t.modFromBytes&&(this._mod=t.modFromBytes)}let{nBitLength:o,nByteLength:s}=function(e,t){void 0!==t&&P(t);let i=void 0!==t?t:e.toString(2).length,r=Math.ceil(i/8);return{nBitLength:i,nByteLength:r}}(e,i);if(s>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=o,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}}function tw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new tv(e,t)}function tx(e){if("bigint"!=typeof e)throw Error("field order must be bigint");return Math.ceil(e.toString(2).length/8)}function tA(e){let t=tx(e);return t+Math.ceil(t/2)}let t_=BigInt(0),tE=BigInt(1);function tI(e,t){let i=t.negate();return e?i:t}function tS(e,t){let i=ty(e.Fp,t.map(e=>e.Z));return t.map((t,r)=>e.fromAffine(t.toAffine(i[r])))}function tU(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw Error("invalid window size, expected [1.."+t+"], got W="+e)}function tT(e,t){tU(e,t);let i=Math.ceil(t/e)+1,r=2**(e-1),n=2**e;return{windows:i,windowSize:r,mask:e6(e),maxNumber:n,shiftBy:BigInt(e)}}function tk(e,t,i){let{windowSize:r,mask:n,maxNumber:o,shiftBy:s}=i,a=Number(e&n),p=e>>s;a>r&&(a-=o,p+=tE);let c=t*r,l=c+Math.abs(a)-1,d=0===a;return{nextN:p,offset:l,isZero:d,isNeg:a<0,isNegF:t%2!=0,offsetF:c}}let tj=new WeakMap,tD=new WeakMap;function tC(e){return tD.get(e)||1}function tB(e){if(e!==t_)throw Error("invalid wNAF")}class tO{_unsafeLadder(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.ZERO,r=e;for(;t>t_;)t&tE&&(i=i.add(r)),r=r.double(),t>>=tE;return i}precomputeWindow(e,t){let{windows:i,windowSize:r}=tT(t,this.bits),n=[],o=e,s=o;for(let e=0;e<i;e++){s=o,n.push(s);for(let e=1;e<r;e++)s=s.add(o),n.push(s);o=s.double()}return n}wNAF(e,t,i){if(!this.Fn.isValid(i))throw Error("invalid scalar");let r=this.ZERO,n=this.BASE,o=tT(e,this.bits);for(let e=0;e<o.windows;e++){let{nextN:s,offset:a,isZero:p,isNeg:c,isNegF:l,offsetF:d}=tk(i,e,o);i=s,p?n=n.add(tI(l,t[d])):r=r.add(tI(c,t[a]))}return tB(i),{p:r,f:n}}wNAFUnsafe(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.ZERO,n=tT(e,this.bits);for(let e=0;e<n.windows&&i!==t_;e++){let{nextN:o,offset:s,isZero:a,isNeg:p}=tk(i,e,n);if(i=o,!a){let e=t[s];r=r.add(p?e.negate():e)}}return tB(i),r}getPrecomputes(e,t,i){let r=tj.get(t);return r||(r=this.precomputeWindow(t,e),1!==e&&("function"==typeof i&&(r=i(r)),tj.set(t,r))),r}cached(e,t,i){let r=tC(e);return this.wNAF(r,this.getPrecomputes(r,e,i),t)}unsafe(e,t,i,r){let n=tC(e);return 1===n?this._unsafeLadder(e,t,r):this.wNAFUnsafe(n,this.getPrecomputes(n,e,i),t,r)}createCache(e,t){tU(t,this.bits),tD.set(e,t),tj.delete(e)}hasCache(e){return 1!==tC(e)}constructor(e,t){(0,n._)(this,"BASE",void 0),(0,n._)(this,"ZERO",void 0),(0,n._)(this,"Fn",void 0),(0,n._)(this,"bits",void 0),this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}}function tR(e,t,i){if(!t)return tw(e,{isLE:i});if(t.ORDER!==e)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return tb(t),t}e8("HashToScalar-");class tq{update(e){return F(this),this.iHash.update(e),this}digestInto(e){F(this),M(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){let e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:i,finished:r,destroyed:n,blockLen:o,outputLen:s}=this;return e.finished=r,e.destroyed=n,e.blockLen=o,e.outputLen=s,e.oHash=t._cloneInto(e.oHash),e.iHash=i._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}constructor(e,t){if((0,n._)(this,"oHash",void 0),(0,n._)(this,"iHash",void 0),(0,n._)(this,"blockLen",void 0),(0,n._)(this,"outputLen",void 0),(0,n._)(this,"finished",!1),(0,n._)(this,"destroyed",!1),N(e),M(t,void 0,"key"),this.iHash=e.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,r=new Uint8Array(i);r.set(t.length>i?e.create().update(t).digest():t);for(let e=0;e<r.length;e++)r[e]^=54;this.iHash.update(r),this.oHash=e.create();for(let e=0;e<r.length;e++)r[e]^=106;this.oHash.update(r),H(r)}}let tL=(e,t,i)=>new tq(e,t).update(i).digest();tL.create=(e,t)=>new tq(e,t);let tP=(e,t)=>(e+(e>=0?t:-t)/tz)/t;function tM(e){if(!["compact","recovered","der"].includes(e))throw Error('Signature format must be "compact", "recovered", or "der"');return e}function tN(e,t){let i={};for(let r of Object.keys(t))i[r]=void 0===e[r]?t[r]:e[r];return eX(i.lowS,"lowS"),eX(i.prehash,"prehash"),void 0!==i.format&&tM(i.format),i}let tF={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(e,t)=>{let{Err:i}=tF;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(1&t.length)throw new i("tlv.encode: unpadded data");let r=t.length/2,n=eJ(r);if(n.length/2&128)throw new i("tlv.encode: long form length too big");let o=r>127?eJ(n.length/2|128):"";return eJ(e)+o+n+t},decode(e,t){let{Err:i}=tF,r=0;if(e<0||e>256)throw new i("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new i("tlv.decode: wrong tlv");let n=t[r++],o=0;if(128&n){let e=127&n;if(!e)throw new i("tlv.decode(long): indefinite length not supported");if(e>4)throw new i("tlv.decode(long): byte length is too big");let s=t.subarray(r,r+e);if(s.length!==e)throw new i("tlv.decode: length bytes not complete");if(0===s[0])throw new i("tlv.decode(long): zero leftmost byte");for(let e of s)o=o<<8|e;if(r+=e,o<128)throw new i("tlv.decode(long): not minimal encoding")}else o=n;let s=t.subarray(r,r+o);if(s.length!==o)throw new i("tlv.decode: wrong value length");return{v:s,l:t.subarray(r+o)}}},_int:{encode(e){let{Err:t}=tF;if(e<tV)throw new t("integer: negative integers are not allowed");let i=eJ(e);if(8&Number.parseInt(i[0],16)&&(i="00"+i),1&i.length)throw new t("unexpected DER parsing assertion: unpadded hex");return i},decode(e){let{Err:t}=tF;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return e$(e)}},toSig(e){let{Err:t,_int:i,_tlv:r}=tF,n=M(e,void 0,"signature"),{v:o,l:s}=r.decode(48,n);if(s.length)throw new t("invalid signature: left bytes after parsing");let{v:a,l:p}=r.decode(2,o),{v:c,l:l}=r.decode(2,p);if(l.length)throw new t("invalid signature: left bytes after parsing");return{r:i.decode(a),s:i.decode(c)}},hexFromSig(e){let{_tlv:t,_int:i}=tF,r=t.encode(2,i.encode(e.r)),n=t.encode(2,i.encode(e.s));return t.encode(48,r+n)}},tV=BigInt(0),tH=BigInt(1),tz=BigInt(2),tW=BigInt(3),tK=BigInt(4);function tZ(e){return Uint8Array.of(e?2:3)}function tG(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}let tX={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},tY={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},tJ=BigInt(0),tQ=BigInt(2),t$=tw(tX.p,{sqrt:function(e){let t=tX.p,i=BigInt(3),r=BigInt(6),n=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),p=BigInt(88),c=e*e*e%t,l=c*c*e%t,d=tc(l,i,t)*l%t,u=tc(d,i,t)*l%t,f=tc(u,tQ,t)*c%t,h=tc(f,n,t)*f%t,g=tc(h,o,t)*h%t,b=tc(g,a,t)*g%t,y=tc(b,p,t)*b%t,m=tc(y,a,t)*g%t,v=tc(m,i,t)*l%t,w=tc(v,s,t)*h%t,x=tc(w,r,t)*c%t,A=tc(x,tQ,t);if(!t$.eql(t$.sqr(A),e))throw Error("Cannot find square root");return A}}),t0=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=function(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3?arguments[3]:void 0;if(void 0===r&&(r="edwards"===e),!t||"object"!=typeof t)throw Error("expected valid ".concat(e," CURVE object"));for(let e of["p","n","h"]){let i=t[e];if(!("bigint"==typeof i&&i>t_))throw Error("CURVE.".concat(e," must be positive bigint"))}let n=tR(t.p,i.Fp,r),o=tR(t.n,i.Fn,r);for(let i of["Gx","Gy","a","weierstrass"===e?"b":"d"])if(!n.isValid(t[i]))throw Error("CURVE.".concat(i," must be valid field element of CURVE.Fp"));return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:n,Fn:o}}("weierstrass",e,t),{Fp:r,Fn:o}=i,s=i.CURVE,{h:a,n:p}=s;e4(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});let{endo:c}=t;if(c&&(!r.is0(s.a)||"bigint"!=typeof c.beta||!Array.isArray(c.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');let l=tG(r,o);function d(){if(!r.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}let u=t.toBytes||function(e,t,i){let{x:n,y:o}=t.toAffine(),s=r.toBytes(n);return(eX(i,"isCompressed"),i)?(d(),ee(tZ(!r.isOdd(o)),s)):ee(Uint8Array.of(4),s,r.toBytes(o))},f=t.fromBytes||function(e){M(e,void 0,"Point");let{publicKey:t,publicKeyUncompressed:i}=l,n=e.length,o=e[0],s=e.subarray(1);if(n===t&&(2===o||3===o)){let e,t=r.fromBytes(s);if(!r.isValid(t))throw Error("bad point: is not on curve, wrong x");let i=h(t);try{e=r.sqrt(i)}catch(e){throw Error("bad point: is not on curve, sqrt error"+(e instanceof Error?": "+e.message:""))}return d(),(1&o)==1!==r.isOdd(e)&&(e=r.neg(e)),{x:t,y:e}}if(n===i&&4===o){let e=r.BYTES,t=r.fromBytes(s.subarray(0,e)),i=r.fromBytes(s.subarray(e,2*e));if(!g(t,i))throw Error("bad point: is not on curve");return{x:t,y:i}}throw Error("bad point: got length ".concat(n,", expected compressed=").concat(t," or uncompressed=").concat(i))};function h(e){let t=r.sqr(e),i=r.mul(t,e);return r.add(r.add(i,r.mul(e,s.a)),s.b)}function g(e,t){let i=r.sqr(t),n=h(e);return r.eql(i,n)}if(!g(s.Gx,s.Gy))throw Error("bad curve params: generator point");let b=r.mul(r.pow(s.a,tW),tK),y=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(b,y)))throw Error("bad curve params: a or b");function m(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!r.isValid(t)||i&&r.is0(t))throw Error("bad point coordinate ".concat(e));return t}function v(e){if(!(e instanceof E))throw Error("Weierstrass Point expected")}function w(e){if(!c||!c.basises)throw Error("no endo");return function(e,t,i){let[[r,n],[o,s]]=t,a=tP(s*e,i),p=tP(-n*e,i),c=e-a*r-p*o,l=-a*n-p*s,d=c<tV,u=l<tV;d&&(c=-c),u&&(l=-l);let f=e6(Math.ceil(function(e){let t;for(t=0;e>eZ;e>>=eG,t+=1);return t}(i)/2))+tH;if(c<tV||c>=f||l<tV||l>=f)throw Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:d,k1:c,k2neg:u,k2:l}}(e,c.basises,o.ORDER)}let x=e5((e,t)=>{let{X:i,Y:n,Z:o}=e;if(r.eql(o,r.ONE))return{x:i,y:n};let s=e.is0();null==t&&(t=s?r.ONE:r.inv(o));let a=r.mul(i,t),p=r.mul(n,t),c=r.mul(o,t);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw Error("invZ was invalid");return{x:a,y:p}}),A=e5(e=>{if(e.is0()){if(t.allowInfinityPoint&&!r.is0(e.Y))return;throw Error("bad point: ZERO")}let{x:i,y:n}=e.toAffine();if(!r.isValid(i)||!r.isValid(n))throw Error("bad point: x or y not field elements");if(!g(i,n))throw Error("bad point: equation left != right");if(!e.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function _(e,t,i,n,o){return i=new E(r.mul(i.X,e),i.Y,i.Z),t=tI(n,t),i=tI(o,i),t.add(i)}class E{static CURVE(){return s}static fromAffine(e){let{x:t,y:i}=e||{};if(!e||!r.isValid(t)||!r.isValid(i))throw Error("invalid affine point");if(e instanceof E)throw Error("projective point not allowed");return r.is0(t)&&r.is0(i)?E.ZERO:new E(t,i,r.ONE)}static fromBytes(e){let t=E.fromAffine(f(M(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return E.fromBytes(Q(e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:8,t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return S.createCache(this,e),t||this.multiply(tW),this}assertValidity(){A(this)}hasEvenY(){let{y:e}=this.toAffine();if(!r.isOdd)throw Error("Field doesn't support isOdd");return!r.isOdd(e)}equals(e){v(e);let{X:t,Y:i,Z:n}=this,{X:o,Y:s,Z:a}=e,p=r.eql(r.mul(t,a),r.mul(o,n)),c=r.eql(r.mul(i,a),r.mul(s,n));return p&&c}negate(){return new E(this.X,r.neg(this.Y),this.Z)}double(){let{a:e,b:t}=s,i=r.mul(t,tW),{X:n,Y:o,Z:a}=this,p=r.ZERO,c=r.ZERO,l=r.ZERO,d=r.mul(n,n),u=r.mul(o,o),f=r.mul(a,a),h=r.mul(n,o);return h=r.add(h,h),l=r.mul(n,a),l=r.add(l,l),p=r.mul(e,l),c=r.mul(i,f),c=r.add(p,c),p=r.sub(u,c),c=r.add(u,c),c=r.mul(p,c),p=r.mul(h,p),l=r.mul(i,l),f=r.mul(e,f),h=r.sub(d,f),h=r.mul(e,h),h=r.add(h,l),l=r.add(d,d),d=r.add(l,d),d=r.add(d,f),d=r.mul(d,h),c=r.add(c,d),f=r.mul(o,a),f=r.add(f,f),d=r.mul(f,h),p=r.sub(p,d),l=r.mul(f,u),l=r.add(l,l),new E(p,c,l=r.add(l,l))}add(e){v(e);let{X:t,Y:i,Z:n}=this,{X:o,Y:a,Z:p}=e,c=r.ZERO,l=r.ZERO,d=r.ZERO,u=s.a,f=r.mul(s.b,tW),h=r.mul(t,o),g=r.mul(i,a),b=r.mul(n,p),y=r.add(t,i),m=r.add(o,a);y=r.mul(y,m),m=r.add(h,g),y=r.sub(y,m),m=r.add(t,n);let w=r.add(o,p);return m=r.mul(m,w),w=r.add(h,b),m=r.sub(m,w),w=r.add(i,n),c=r.add(a,p),w=r.mul(w,c),c=r.add(g,b),w=r.sub(w,c),d=r.mul(u,m),c=r.mul(f,b),d=r.add(c,d),c=r.sub(g,d),d=r.add(g,d),l=r.mul(c,d),g=r.add(h,h),g=r.add(g,h),b=r.mul(u,b),m=r.mul(f,m),g=r.add(g,b),b=r.sub(h,b),b=r.mul(u,b),m=r.add(m,b),h=r.mul(g,m),l=r.add(l,h),h=r.mul(w,m),c=r.mul(y,c),c=r.sub(c,h),h=r.mul(y,g),d=r.mul(w,d),new E(c,l,d=r.add(d,h))}subtract(e){return this.add(e.negate())}is0(){return this.equals(E.ZERO)}multiply(e){let i,r,{endo:n}=t;if(!o.isValidNot0(e))throw Error("invalid scalar: out of range");let s=e=>S.cached(this,e,e=>tS(E,e));if(n){let{k1neg:t,k1:o,k2neg:a,k2:p}=w(e),{p:c,f:l}=s(o),{p:d,f:u}=s(p);r=l.add(u),i=_(n.beta,c,d,t,a)}else{let{p:t,f:n}=s(e);i=t,r=n}return tS(E,[i,r])[0]}multiplyUnsafe(e){let{endo:i}=t;if(!o.isValid(e))throw Error("invalid scalar: out of range");if(e===tV||this.is0())return E.ZERO;if(e===tH)return this;if(S.hasCache(this))return this.multiply(e);if(!i)return S.unsafe(this,e);{let{k1neg:t,k1:r,k2neg:n,k2:o}=w(e),{p1:s,p2:a}=function(e,t,i,r){let n=t,o=e.ZERO,s=e.ZERO;for(;i>t_||r>t_;)i&tE&&(o=o.add(n)),r&tE&&(s=s.add(n)),n=n.double(),i>>=tE,r>>=tE;return{p1:o,p2:s}}(E,this,r,o);return _(i.beta,s,a,t,n)}}toAffine(e){return x(this,e)}isTorsionFree(){let{isTorsionFree:e}=t;return a===tH||(e?e(E,this):S.unsafe(this,p).is0())}clearCofactor(){let{clearCofactor:e}=t;return a===tH?this:e?e(E,this):this.multiplyUnsafe(a)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}toBytes(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];return eX(e,"isCompressed"),this.assertValidity(),u(E,this,e)}toHex(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];return X(this.toBytes(e))}toString(){return"<Point ".concat(this.is0()?"ZERO":this.toHex(),">")}constructor(e,t,i){(0,n._)(this,"X",void 0),(0,n._)(this,"Y",void 0),(0,n._)(this,"Z",void 0),this.X=m("x",e),this.Y=m("y",t,!0),this.Z=m("z",i),Object.freeze(this)}}(0,n._)(E,"BASE",new E(s.Gx,s.Gy,r.ONE)),(0,n._)(E,"ZERO",new E(r.ZERO,r.ONE,r.ZERO)),(0,n._)(E,"Fp",r),(0,n._)(E,"Fn",o);let I=o.BITS,S=new tO(E,t.endo?Math.ceil(I/2):I);return E.BASE.precompute(8),E}(tX,{Fp:t$,endo:tY}),t1=function(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};N(t),e4(i,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let r=(i=Object.assign({},i)).randomBytes||ei,o=i.hmac||((e,i)=>tL(t,e,i)),{Fp:s,Fn:a}=e,{ORDER:p,BITS:c}=a,{keygen:l,getPublicKey:d,getSharedSecret:u,utils:f,lengths:h}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{Fn:i}=e,r=t.randomBytes||ei,n=Object.assign(tG(e.Fp,i),{seed:tA(i.ORDER)});function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r(n.seed);return function(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];M(e);let r=e.length,n=tx(t),o=tA(t);if(r<16||r<o||r>1024)throw Error("expected "+o+"-1024 bytes of input, got "+r);let s=tp(i?e0(e):e$(e),t-e9)+e9;return i?e2(s,n):e1(s,n)}(M(e,n.seed,"seed"),i.ORDER)}function s(t){let r=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return e.BASE.multiply(i.fromBytes(t)).toBytes(r)}function a(e){let{secretKey:t,publicKey:r,publicKeyUncompressed:o}=n;if(!L(e)||"_lengths"in i&&i._lengths||t===r)return;let s=M(e,void 0,"key").length;return s===r||s===o}let p=function(e){let t=o(e);return{secretKey:t,publicKey:s(t)}};return Object.freeze({getPublicKey:s,getSharedSecret:function(t,r){let n=!(arguments.length>2)||void 0===arguments[2]||arguments[2];if(!0===a(t))throw Error("first arg must be private key");if(!1===a(r))throw Error("second arg must be public key");let o=i.fromBytes(t);return e.fromBytes(r).multiply(o).toBytes(n)},keygen:p,Point:e,utils:{isValidSecretKey:function(e){try{let t=i.fromBytes(e);return i.isValidNot0(t)}catch(e){return!1}},isValidPublicKey:function(t,i){let{publicKey:r,publicKeyUncompressed:o}=n;try{let n=t.length;if(!0===i&&n!==r||!1===i&&n!==o)return!1;return!!e.fromBytes(t)}catch(e){return!1}},randomSecretKey:o},lengths:n})}(e,i),g={prehash:!0,lowS:"boolean"!=typeof i.lowS||i.lowS,format:"compact",extraEntropy:!1},b=p*tz<s.ORDER;function y(e,t){if(!a.isValidNot0(t))throw Error("invalid signature ".concat(e,": out of range 1..Point.Fn.ORDER"));return t}function m(){if(b)throw Error('"recovered" sig type is not supported for cofactor >2 curves')}function v(e,t){tM(t);let i=h.signature;return M(e,"compact"===t?i:"recovered"===t?i+1:void 0)}class w{static fromBytes(e){let t,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.format;if(v(e,i),"der"===i){let{r:t,s:i}=tF.toSig(M(e));return new w(t,i)}"recovered"===i&&(t=e[0],i="compact",e=e.subarray(1));let r=h.signature/2,n=e.subarray(0,r),o=e.subarray(r,2*r);return new w(a.fromBytes(n),a.fromBytes(o),t)}static fromHex(e,t){return this.fromBytes(Q(e),t)}assertRecovery(){let{recovery:e}=this;if(null==e)throw Error("invalid recovery id: must be present");return e}addRecoveryBit(e){return new w(this.r,this.s,e)}recoverPublicKey(t){let{r:i,s:r}=this,n=this.assertRecovery(),o=2===n||3===n?i+p:i;if(!s.isValid(o))throw Error("invalid recovery id: sig.r+curve.n != R.x");let c=s.toBytes(o),l=e.fromBytes(ee(tZ((1&n)==0),c)),d=a.inv(o),u=A(M(t,void 0,"msgHash")),f=a.create(-u*d),h=a.create(r*d),g=e.BASE.multiplyUnsafe(f).add(l.multiplyUnsafe(h));if(g.is0())throw Error("invalid recovery: point at infinify");return g.assertValidity(),g}hasHighS(){return this.s>p>>tH}toBytes(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:g.format;if(tM(e),"der"===e)return Q(tF.hexFromSig(this));let{r:t,s:i}=this,r=a.toBytes(t),n=a.toBytes(i);return"recovered"===e?(m(),ee(Uint8Array.of(this.assertRecovery()),r,n)):ee(r,n)}toHex(e){return X(this.toBytes(e))}constructor(e,t,i){if((0,n._)(this,"r",void 0),(0,n._)(this,"s",void 0),(0,n._)(this,"recovery",void 0),this.r=y("r",e),this.s=y("s",t),null!=i){if(m(),![0,1,2,3].includes(i))throw Error("invalid recovery id");this.recovery=i}Object.freeze(this)}}let x=i.bits2int||function(e){if(e.length>8192)throw Error("input is too large");let t=e$(e),i=8*e.length-c;return i>0?t>>BigInt(i):t},A=i.bits2int_modN||function(e){return a.create(x(e))},_=e6(c);function E(e){return!function(e,t,i,r){if(!(e3(t)&&e3(i)&&e3(r))||!(i<=t)||!(t<r))throw Error("expected valid "+e+": "+i+" <= n < "+r+", got "+t)}("num < 2^"+c,e,tV,_),a.toBytes(e)}function I(e,i){return M(e,void 0,"message"),i?M(t(e),void 0,"prehashed message"):e}return Object.freeze({keygen:l,getPublicKey:d,getSharedSecret:u,utils:f,lengths:h,Point:e,sign:function(i,n){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{seed:c,k2sig:l}=function(t,i,n){let{lowS:o,prehash:s,extraEntropy:c}=tN(n,g),l=A(t=I(t,s)),d=a.fromBytes(i);if(!a.isValidNot0(d))throw Error("invalid private key");let u=[E(d),E(l)];if(null!=c&&!1!==c){let e=!0===c?r(h.secretKey):c;u.push(M(e,void 0,"extraEntropy"))}return{seed:ee(...u),k2sig:function(t){let i=x(t);if(!a.isValidNot0(i))return;let r=a.inv(i),n=e.BASE.multiply(i).toAffine(),s=a.create(n.x);if(s===tV)return;let c=a.create(r*a.create(l+s*d));if(c===tV)return;let u=2*(n.x!==s)|Number(n.y&tH),f=c;return o&&c>p>>tH&&(f=a.neg(c),u^=1),new w(s,f,b?void 0:u)}}}(i,n,s);return(function(e,t,i){if(P(e,"hashLen"),P(t,"qByteLen"),"function"!=typeof i)throw Error("hmacFn must be a function");let r=e=>new Uint8Array(e),n=Uint8Array.of(),o=Uint8Array.of(0),s=Uint8Array.of(1),a=r(e),p=r(e),c=0,l=()=>{a.fill(1),p.fill(0),c=0},d=function(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];return i(p,ee(a,...t))},u=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;p=d(o,e),a=d(),0!==e.length&&(p=d(s,e),a=d())},f=()=>{if(c++>=1e3)throw Error("drbg: tried max amount of iterations");let e=0,i=[];for(;e<t;){let t=(a=d()).slice();i.push(t),e+=a.length}return ee(...i)};return(e,t)=>{let i;for(l(),u(e);!(i=t(f()));)u();return l(),i}})(t.outputLen,a.BYTES,o)(c,l).toBytes(s.format)},verify:function(t,i,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},{lowS:o,prehash:s,format:p}=tN(n,g);if(r=M(r,void 0,"publicKey"),i=I(i,s),!L(t))throw Error("verify expects Uint8Array signature"+(t instanceof w?", use sig.toBytes()":""));v(t,p);try{let n=w.fromBytes(t,p),s=e.fromBytes(r);if(o&&n.hasHighS())return!1;let{r:c,s:l}=n,d=A(i),u=a.inv(l),f=a.create(d*u),h=a.create(c*u),g=e.BASE.multiplyUnsafe(f).add(s.multiplyUnsafe(h));if(g.is0())return!1;return a.create(g.x)===c}catch(e){return!1}},recoverPublicKey:function(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{prehash:r}=tN(i,g);return t=I(t,r),w.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:w,hash:t})}(t0,eK);function t2(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}(function(e,t){t.map(e=>Array.from(e).reverse())})(t$,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(e=>BigInt(e)))),function(e,t){tb(e);let{A:i,B:r,Z:n}=t;if(!e.isValid(i)||!e.isValid(r)||!e.isValid(n))throw Error("mapToCurveSimpleSWU: invalid opts");(function(e,t){let i=e.ORDER,r=tV;for(let e=i-tH;e%tz===tV;e/=tz)r+=tH;let n=r,o=tz<<n-tH-tH,s=o*tz,a=(i-tH)/s,p=(a-tH)/tz,c=s-tH,l=e.pow(t,a),d=e.pow(t,(a+tH)/tz),u=(t,i)=>{let r=l,s=e.pow(i,c),a=e.sqr(s);a=e.mul(a,i);let u=e.mul(t,a);u=e.pow(u,p),u=e.mul(u,s),s=e.mul(u,i),a=e.mul(u,t);let f=e.mul(a,s);u=e.pow(f,o);let h=e.eql(u,e.ONE);s=e.mul(a,d),u=e.mul(f,r),a=e.cmov(s,a,h),f=e.cmov(u,f,h);for(let t=n;t>tH;t--){let i=t-tz;i=tz<<i-tH;let n=e.pow(f,i),o=e.eql(n,e.ONE);s=e.mul(a,r),r=e.mul(r,r),n=e.mul(f,r),a=e.cmov(s,a,o),f=e.cmov(n,f,o)}return{isValid:h,value:a}};if(e.ORDER%tK===tW){let i=(e.ORDER-tW)/tK,r=e.sqrt(e.neg(t));u=(t,n)=>{let o=e.sqr(n),s=e.mul(t,n);o=e.mul(o,s);let a=e.pow(o,i);a=e.mul(a,s);let p=e.mul(a,r),c=e.mul(e.sqr(a),n),l=e.eql(c,t),d=e.cmov(p,a,l);return{isValid:l,value:d}}};})(e,n);if(!e.isOdd)throw Error("Field does not have .isOdd()")}(t$,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:t$.create(BigInt("-11"))});function t8(e,t){return!!Array.isArray(t)&&(0===t.length||(e?t.every(e=>"string"==typeof e):t.every(e=>Number.isSafeInteger(e))))}function t3(e){if("function"!=typeof e)throw Error("function expected");return!0}function t6(e,t){if("string"!=typeof t)throw Error("".concat(e,": string expected"));return!0}function t4(e){if(!Number.isSafeInteger(e))throw Error("invalid integer: ".concat(e))}function t5(e){if(!Array.isArray(e))throw Error("array expected")}function t7(e,t){if(!t8(!0,t))throw Error("".concat(e,": array of strings expected"))}function t9(e,t){if(!t8(!1,t))throw Error("".concat(e,": array of numbers expected"))}function ie(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];let r=e=>e,n=(e,t)=>i=>e(t(i));return{encode:t.map(e=>e.encode).reduceRight(n,r),decode:t.map(e=>e.decode).reduce(n,r)}}function it(e){let t="string"==typeof e?e.split(""):e,i=t.length;t7("alphabet",t);let r=new Map(t.map((e,t)=>[e,t]));return{encode:r=>(t5(r),r.map(r=>{if(!Number.isSafeInteger(r)||r<0||r>=i)throw Error('alphabet.encode: digit index outside alphabet "'.concat(r,'". Allowed: ').concat(e));return t[r]})),decode:t=>(t5(t),t.map(t=>{t6("alphabet.decode",t);let i=r.get(t);if(void 0===i)throw Error('Unknown letter: "'.concat(t,'". Allowed: ').concat(e));return i}))}}function ii(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return t6("join",e),{encode:t=>(t7("join.decode",t),t.join(e)),decode:t=>(t6("join.decode",t),t.split(e))}}function ir(e,t,i){if(t<2)throw Error("convertRadix: invalid from=".concat(t,", base cannot be less than 2"));if(i<2)throw Error("convertRadix: invalid to=".concat(i,", base cannot be less than 2"));if(t5(e),!e.length)return[];let r=0,n=[],o=Array.from(e,e=>{if(t4(e),e<0||e>=t)throw Error("invalid integer: ".concat(e));return e}),s=o.length;for(;;){let e=0,a=!0;for(let n=r;n<s;n++){let s=o[n],p=t*e,c=p+s;if(!Number.isSafeInteger(c)||p/t!==e||c-s!==p)throw Error("convertRadix: carry overflow");let l=c/i;e=c%i;let d=Math.floor(l);if(o[n]=d,!Number.isSafeInteger(d)||d*i+e!==c)throw Error("convertRadix: carry overflow");a&&(d?a=!1:r=n)}if(n.push(e),a)break}for(let t=0;t<e.length-1&&0===e[t];t++)n.push(0);return n.reverse()}let io=(e,t)=>0===t?e:io(t,e%t),is=(e,t)=>e+(t-io(e,t)),ia=(()=>{let e=[];for(let t=0;t<40;t++)e.push(2**t);return e})();function ip(e,t,i,r){if(t5(e),t<=0||t>32)throw Error("convertRadix2: wrong from=".concat(t));if(i<=0||i>32)throw Error("convertRadix2: wrong to=".concat(i));if(is(t,i)>32)throw Error("convertRadix2: carry overflow from=".concat(t," to=").concat(i," carryBits=").concat(is(t,i)));let n=0,o=0,s=ia[t],a=ia[i]-1,p=[];for(let r of e){if(t4(r),r>=s)throw Error("convertRadix2: invalid data word=".concat(r," from=").concat(t));if(n=n<<t|r,o+t>32)throw Error("convertRadix2: carry overflow pos=".concat(o," from=").concat(t));for(o+=t;o>=i;o-=i)p.push((n>>o-i&a)>>>0);let e=ia[o];if(void 0===e)throw Error("invalid carry");n&=e-1}if(n=n<<i-o&a,!r&&o>=t)throw Error("Excess padding");if(!r&&n>0)throw Error("Non-zero padding: ".concat(n));return r&&o>0&&p.push(n>>>0),p}"function"==typeof Uint8Array.from([]).toBase64&&Uint8Array.fromBase64;r=58,t4(58);let ic="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex?{encode:e=>((function(e){if(!t2(e))throw Error("Uint8Array expected")})(e),e.toHex()),decode:e=>(t6("hex",e),Uint8Array.fromHex(e))}:ie(function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t4(e),e<=0||e>32)throw Error("radix2: bits should be in (0..32]");if(is(8,e)>32||is(e,8)>32)throw Error("radix2: carry overflow");return{encode:i=>{if(!t2(i))throw Error("radix2.encode input should be Uint8Array");return ip(Array.from(i),8,e,!t)},decode:i=>(t9("radix2.decode",i),Uint8Array.from(ip(i,e,8,t)))}}(4),it("0123456789abcdef"),ii(""),function(e){return t3(e),{encode:e=>e,decode:t=>e(t)}}(e=>{if("string"!=typeof e||e.length%2!=0)throw TypeError("hex.decode: expected string, got ".concat(typeof e," with length ").concat(e.length));return e.toLowerCase()}));function il(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}let id=e=>new DataView(e.buffer,e.byteOffset,e.byteLength);function iu(e){return"[object Object]"===Object.prototype.toString.call(e)}function ih(e){return Number.isSafeInteger(e)}let ig={BITS:32,FULL_MASK:0xffffffff,len:e=>Math.ceil(e/32),create:e=>new Uint32Array(ig.len(e)),clean:e=>e.fill(0),debug:e=>Array.from(e).map(e=>(e>>>0).toString(2).padStart(32,"0")),checkLen:(e,t)=>{if(ig.len(t)!==e.length)throw Error("wrong length=".concat(e.length,". Expected: ").concat(ig.len(t)))},chunkLen:(e,t,i)=>{if(t<0)throw Error("wrong pos=".concat(t));if(t+i>e)throw Error("wrong range=".concat(t,"/").concat(i," of ").concat(e))},set:function(e,t,i){let r=!(arguments.length>3)||void 0===arguments[3]||arguments[3];return(!!r||(e[t]&i)==0)&&(e[t]|=i,!0)},pos:(e,t)=>({chunk:Math.floor((e+t)/32),mask:1<<32-(e+t)%32-1}),indices:function(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];ig.checkLen(e,t);let{FULL_MASK:r,BITS:n}=ig,o=n-t%n,s=o?r>>>o<<o:r,a=[];for(let t=0;t<e.length;t++){let r=e[t];if(i&&(r=~r),t===e.length-1&&(r&=s),0!==r)for(let e=0;e<n;e++)r&1<<n-e-1&&a.push(t*n+e)}return a},range:e=>{let t,i=[];for(let r of e)void 0===t||r!==t.pos+t.length?i.push(t={pos:r,length:1}):t.length+=1;return i},rangeDebug:function(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return"[".concat(ig.range(ig.indices(e,t,i)).map(e=>"(".concat(e.pos,"/").concat(e.length,")")).join(", "),"]")},setRange:function(e,t,i,r){let n=!(arguments.length>4)||void 0===arguments[4]||arguments[4];ig.chunkLen(t,i,r);let{FULL_MASK:o,BITS:s}=ig,a=i%s?Math.floor(i/s):void 0,p=i+r,c=p%s?Math.floor(p/s):void 0;if(void 0!==a&&a===c)return ig.set(e,a,o>>>s-r<<s-r-i,n);if(void 0!==a&&!ig.set(e,a,o>>>i%s,n))return!1;let l=void 0!==a?a+1:i/s,d=void 0!==c?c:p/s;for(let t=l;t<d;t++)if(!ig.set(e,t,o,n))return!1;return void 0===c||a===c||!!ig.set(e,c,o<<s-p%s,n)}},ib={pushObj:(e,t,i)=>{let r={obj:t};e.push(r),i((e,t)=>{r.field=e,t(),r.field=void 0}),e.pop()},path:e=>{let t=[];for(let i of e)void 0!==i.field&&t.push(i.field);return t.join("/")},err:(e,t,i)=>{let r=Error("".concat(e,"(").concat(ib.path(t),"): ").concat("string"==typeof i?i:i.message));return i instanceof Error&&i.stack&&(r.stack=i.stack),r},resolve:(e,t)=>{let i=t.split("/"),r=e.map(e=>e.obj),n=0;for(;n<i.length;n++)if(".."===i[n])r.pop();else break;let o=r.pop();for(;n<i.length;n++){if(!o||void 0===o[i[n]])return;o=o[i[n]]}return o}};class iy{_enablePointers(){if(this.parent)return this.parent._enablePointers();this.bs||(this.bs=ig.create(this.data.length),ig.setRange(this.bs,this.data.length,0,this.pos,this.opts.allowMultipleReads))}markBytesBS(e,t){return this.parent?this.parent.markBytesBS(this.parentOffset+e,t):!t||!this.bs||ig.setRange(this.bs,this.data.length,e,t,!1)}markBytes(e){let t=this.pos;this.pos+=e;let i=this.markBytesBS(t,e);if(!this.opts.allowMultipleReads&&!i)throw this.err("multiple read pos=".concat(this.pos," len=").concat(e));return i}pushObj(e,t){return ib.pushObj(this.stack,e,t)}readView(e,t){if(!Number.isFinite(e))throw this.err("readView: wrong length=".concat(e));if(this.pos+e>this.data.length)throw this.err("readView: Unexpected end of buffer");let i=t(this.view,this.pos);return this.markBytes(e),i}absBytes(e){if(e>this.data.length)throw Error("Unexpected end of buffer");return this.data.subarray(e)}finish(){if(!this.opts.allowUnreadBytes){if(this.bitPos)throw this.err("".concat(this.bitPos," bits left after unpack: ").concat(ic.encode(this.data.slice(this.pos))));if(this.bs&&!this.parent){let e=ig.indices(this.bs,this.data.length,!0);if(!e.length)return;{let t=ig.range(e).map(e=>{let{pos:t,length:i}=e;return"(".concat(t,"/").concat(i,")[").concat(ic.encode(this.data.subarray(t,t+i)),"]")}).join(", ");throw this.err("unread byte ranges: ".concat(t," (total=").concat(this.data.length,")"))}}if(!this.isEnd())throw this.err("".concat(this.leftBytes," bytes ").concat(this.bitPos," bits left after unpack: ").concat(ic.encode(this.data.slice(this.pos))))}}err(e){return ib.err("Reader",this.stack,e)}offsetReader(e){if(e>this.data.length)throw this.err("offsetReader: Unexpected end of buffer");return new iy(this.absBytes(e),this.opts,this.stack,this,e)}bytes(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.bitPos)throw this.err("readBytes: bitPos not empty");if(!Number.isFinite(e))throw this.err("readBytes: wrong length=".concat(e));if(this.pos+e>this.data.length)throw this.err("readBytes: Unexpected end of buffer");let i=this.data.subarray(this.pos,this.pos+e);return t||this.markBytes(e),i}byte(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.bitPos)throw this.err("readByte: bitPos not empty");if(this.pos+1>this.data.length)throw this.err("readBytes: Unexpected end of buffer");let t=this.data[this.pos];return e||this.markBytes(1),t}get leftBytes(){return this.data.length-this.pos}get totalBytes(){return this.data.length}isEnd(){return this.pos>=this.data.length&&!this.bitPos}bits(e){if(e>32)throw this.err("BitReader: cannot read more than 32 bits in single call");let t=0;for(;e;){this.bitPos||(this.bitBuf=this.byte(),this.bitPos=8);let i=Math.min(e,this.bitPos);this.bitPos-=i,t=t<<i|this.bitBuf>>this.bitPos&2**i-1,this.bitBuf&=2**this.bitPos-1,e-=i}return t>>>0}find(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.pos;if(!il(e))throw this.err("find: needle is not bytes! ".concat(e));if(this.bitPos)throw this.err("findByte: bitPos not empty");if(!e.length)throw this.err("find: needle is empty");for(let i=t;-1!==(i=this.data.indexOf(e[0],i))&&-1!==i&&!(this.data.length-i<e.length);i++)if(function(e,t){if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0}(e,this.data.subarray(i,i+e.length)))return i}constructor(e,t={},i=[],r,o=0){(0,n._)(this,"pos",0),(0,n._)(this,"data",void 0),(0,n._)(this,"opts",void 0),(0,n._)(this,"stack",void 0),(0,n._)(this,"parent",void 0),(0,n._)(this,"parentOffset",void 0),(0,n._)(this,"bitBuf",0),(0,n._)(this,"bitPos",0),(0,n._)(this,"bs",void 0),(0,n._)(this,"view",void 0),this.data=e,this.opts=t,this.stack=i,this.parent=r,this.parentOffset=o,this.view=id(e)}}class im{pushObj(e,t){return ib.pushObj(this.stack,e,t)}writeView(e,t){if(this.finished)throw this.err("buffer: finished");if(!ih(e)||e>8)throw Error("wrong writeView length=".concat(e));t(this.view),this.bytes(this.viewBuf.slice(0,e)),this.viewBuf.fill(0)}err(e){if(this.finished)throw this.err("buffer: finished");return ib.err("Reader",this.stack,e)}bytes(e){if(this.finished)throw this.err("buffer: finished");if(this.bitPos)throw this.err("writeBytes: ends with non-empty bit buffer");this.buffers.push(e),this.pos+=e.length}byte(e){if(this.finished)throw this.err("buffer: finished");if(this.bitPos)throw this.err("writeByte: ends with non-empty bit buffer");this.buffers.push(new Uint8Array([e])),this.pos++}finish(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];if(this.finished)throw this.err("buffer: finished");if(this.bitPos)throw this.err("buffer: ends with non-empty bit buffer");let t=this.buffers.concat(this.ptrs.map(e=>e.buffer)),i=new Uint8Array(t.map(e=>e.length).reduce((e,t)=>e+t,0));for(let e=0,r=0;e<t.length;e++){let n=t[e];i.set(n,r),r+=n.length}for(let e=this.pos,t=0;t<this.ptrs.length;t++){let r=this.ptrs[t];i.set(r.ptr.encode(e),r.pos),e+=r.buffer.length}if(e){for(let e of(this.buffers=[],this.ptrs))e.buffer.fill(0);this.ptrs=[],this.finished=!0,this.bitBuf=0}return i}bits(e,t){if(t>32)throw this.err("writeBits: cannot write more than 32 bits in single call");if(e>=2**t)throw this.err("writeBits: value (".concat(e,") >= 2**bits (").concat(t,")"));for(;t;){let i=Math.min(t,8-this.bitPos);this.bitBuf=this.bitBuf<<i|e>>t-i,this.bitPos+=i,t-=i,e&=2**t-1,8===this.bitPos&&(this.bitPos=0,this.buffers.push(new Uint8Array([this.bitBuf])),this.pos++)}}constructor(e=[]){(0,n._)(this,"pos",0),(0,n._)(this,"stack",void 0),(0,n._)(this,"buffers",[]),(0,n._)(this,"ptrs",[]),(0,n._)(this,"bitBuf",0),(0,n._)(this,"bitPos",0),(0,n._)(this,"viewBuf",new Uint8Array(8)),(0,n._)(this,"view",void 0),(0,n._)(this,"finished",!1),this.stack=e,this.view=id(this.viewBuf)}}function iv(e){return{encodeStream:e.encodeStream,decodeStream:e.decodeStream,size:e.size,encode:t=>{let i=new im;return e.encodeStream(i,t),i.finish()},decode:function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=new iy(t,i),n=e.decodeStream(r);return r.finish(),n}}}let iw=e=>{let t=iv(e);return e.validate?function(e,t){if(!ix(e))throw Error("validate: invalid inner value ".concat(e));if("function"!=typeof t)throw Error("validate: fn should be function");return iv({size:e.size,encodeStream:(i,r)=>{let n;try{n=t(r)}catch(e){throw i.err(e)}e.encodeStream(i,n)},decodeStream:i=>{let r=e.decodeStream(i);try{return t(r)}catch(e){throw i.err(e)}}})}(t,e.validate):t};function ix(e){let t;return iu(e)&&iu(t=e)&&"function"==typeof t.decode&&"function"==typeof t.encode&&"function"==typeof e.encodeStream&&"function"==typeof e.decodeStream&&(void 0===e.size||ih(e.size))}let iA=((e,t,i)=>{let r=8*e,n=2**(r-1),o=2**r;return((e,t)=>iw({size:e,encodeStream:(i,r)=>i.writeView(e,e=>t.write(e,r)),decodeStream:i=>i.readView(e,t.read),validate:e=>{if("number"!=typeof e)throw Error("viewCoder: expected number, got ".concat(typeof e));return t.validate&&t.validate(e),e}}))(e,{write:i.write,read:i.read,validate:t?e=>{if(!ih(e))throw Error("sintView: value is not safe integer: ".concat(e));if(e<-n||e>=n)throw Error("sintView: value out of bounds. Expected ".concat(-n," <= ").concat(e," < ").concat(n))}:e=>{if(!ih(e))throw Error("uintView: value is not safe integer: ".concat(e));if(0>e||e>=o)throw Error("uintView: value out of bounds. Expected 0 <= ".concat(e," < ").concat(o))}})})(4,!1,{read:(e,t)=>e.getUint32(t,!1),write:(e,t)=>e.setUint32(0,t,!1)}),i_=e=>0;function iE(e,t){return t%e==0?0:e-t%e}BigInt(10),BigInt(9),BigInt(10),BigInt(18);let iI=/^0+/,iS=function(){let e=!(arguments.length>0)||void 0===arguments[0]||arguments[0];return{decode:e=>{if("string"!=typeof e)throw Error("hex data must be a string");let t=ik(e);return Q(t=1&t.length?"0".concat(t):t)},encode:t=>{let i=X(t);return e||(i=i.replace(iI,"")),iT(i)}}}(!0),iU=/^0[xX]/;function iT(e){return iU.test(e)?e:"0x".concat(e)}function ik(e){return e.replace(iU,"")}let ij=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!ih(e))throw Error("decimal/precision: wrong value ".concat(e));if("boolean"!=typeof t)throw Error("decimal/round: expected boolean, got ".concat(typeof t));let i=10n**BigInt(e);return{encode:t=>{if("bigint"!=typeof t)throw Error("expected bigint, got ".concat(typeof t));let i=(t<0n?-t:t).toString(10),r=i.length-e;r<0&&(i=i.padStart(i.length-r,"0"),r=0);let n=i.length-1;for(;n>=r&&"0"===i[n];n--);let o=i.slice(0,r),s=i.slice(r,n+1);return(o||(o="0"),t<0n&&(o="-"+o),s)?"".concat(o,".").concat(s):o},decode:r=>{if("string"!=typeof r)throw Error("expected string, got ".concat(typeof r));if("-0"===r)throw Error("negative zero is not allowed");let n=!1;if(r.startsWith("-")&&(n=!0,r=r.slice(1)),!/^(0|[1-9]\d*)(\.\d+)?$/.test(r))throw Error("wrong string value=".concat(r));let o=r.indexOf(".");o=-1===o?r.length:o;let s=r.slice(0,o),a=r.slice(o+1).replace(/0+$/,""),p=BigInt(s)*i;if(!t&&a.length>e)throw Error("fractional part cannot be represented with this precision (num=".concat(r,", prec=").concat(e,")"));let c=Math.min(a.length,e),l=p+BigInt(a.slice(0,c))*10n**BigInt(e-c);return n?-l:l}}};ij(18),ij(9);function iD(e){let{action:t,nonce:i,vaultAddress:r,expiresAfter:n}=e,o=function(e){let t=[];!function e(t,i){if(null===t)return void i.push(new Uint8Array([192]));if(!1===t)return void i.push(new Uint8Array([194]));if(!0===t)return void i.push(new Uint8Array([195]));if("number"==typeof t)return void i.push(function(e){if(!Number.isInteger(e))return ew(e);if(e<0){if(e>=-32)return new Uint8Array([e]);if(e>=-128)return new Uint8Array([208,e]);if(e>=-32768){let t=new DataView(new ArrayBuffer(3));return t.setInt16(1,e),t.setUint8(0,209),new Uint8Array(t.buffer)}if(e>=-0x80000000){let t=new DataView(new ArrayBuffer(5));return t.setInt32(1,e),t.setUint8(0,210),new Uint8Array(t.buffer)}return ew(e)}if(e<=127)return new Uint8Array([e]);if(e<256)return new Uint8Array([204,e]);if(e<65536){let t=new DataView(new ArrayBuffer(3));return t.setUint16(1,e),t.setUint8(0,205),new Uint8Array(t.buffer)}if(e<0x100000000){let t=new DataView(new ArrayBuffer(5));return t.setUint32(1,e),t.setUint8(0,206),new Uint8Array(t.buffer)}return ew(e)}(t));if("bigint"==typeof t){if(t<0){if(t<-0x8000000000000000n)throw Error("Cannot safely encode bigint larger than 64 bits");let e=new DataView(new ArrayBuffer(9));e.setBigInt64(1,t),e.setUint8(0,211),i.push(new Uint8Array(e.buffer));return}if(t>=0x10000000000000000n)throw Error("Cannot safely encode bigint larger than 64 bits");let e=new DataView(new ArrayBuffer(9));e.setBigUint64(1,t),e.setUint8(0,207),i.push(new Uint8Array(e.buffer));return}if("string"==typeof t){let e=ev.encode(t),r=e.length;if(r<32)i.push(new Uint8Array([160|r]));else if(r<256)i.push(new Uint8Array([217,r]));else if(r<65536){let e=new DataView(new ArrayBuffer(3));e.setUint16(1,r),e.setUint8(0,218),i.push(new Uint8Array(e.buffer))}else if(r<0x100000000){let e=new DataView(new ArrayBuffer(5));e.setUint32(1,r),e.setUint8(0,219),i.push(new Uint8Array(e.buffer))}else throw Error("Cannot safely encode string with size larger than 32 bits");i.push(e);return}if(t instanceof Uint8Array){if(t.length<256)i.push(new Uint8Array([196,t.length]));else if(t.length<65536){let e=new DataView(new ArrayBuffer(3));e.setUint16(1,t.length),e.setUint8(0,197),i.push(new Uint8Array(e.buffer))}else if(t.length<0x100000000){let e=new DataView(new ArrayBuffer(5));e.setUint32(1,t.length),e.setUint8(0,198),i.push(new Uint8Array(e.buffer))}else throw Error("Cannot safely encode Uint8Array with size larger than 32 bits");i.push(t);return}if(Array.isArray(t)){if(t.length<16)i.push(new Uint8Array([144|t.length]));else if(t.length<65536){let e=new DataView(new ArrayBuffer(3));e.setUint16(1,t.length),e.setUint8(0,220),i.push(new Uint8Array(e.buffer))}else if(t.length<0x100000000){let e=new DataView(new ArrayBuffer(5));e.setUint32(1,t.length),e.setUint8(0,221),i.push(new Uint8Array(e.buffer))}else throw Error("Cannot safely encode array with size larger than 32 bits");for(let r of t)e(r,i);return}let r=Object.getPrototypeOf(t);if(null===r||r===Object.prototype){let r=Object.keys(t).length;if(r<16)i.push(new Uint8Array([128|r]));else if(r<65536){let e=new DataView(new ArrayBuffer(3));e.setUint16(1,r),e.setUint8(0,222),i.push(new Uint8Array(e.buffer))}else if(r<0x100000000){let e=new DataView(new ArrayBuffer(5));e.setUint32(1,r),e.setUint8(0,223),i.push(new Uint8Array(e.buffer))}else throw Error("Cannot safely encode map with size larger than 32 bits");for(let[r,n]of Object.entries(t))e(r,i),e(n,i);return}throw Error("Cannot safely encode value into messagepack")}(e,t);let i=0;for(let e of t)i+=e.length;let r=new Uint8Array(i),n=0;for(let e of t)r.set(e,n),n+=e.length;return r}(function e(t){if("number"==typeof t&&Number.isInteger(t)&&(t>=0x100000000||t<-0x80000000))return BigInt(t);if(Array.isArray(t))return t.map(e);if("object"==typeof t&&null!==t){let i={};for(let r in t)i[r]=e(t[r]);return i}return t}(function e(t){if(Array.isArray(t))return t.map(e);if("object"==typeof t&&null!==t){let i={};for(let r in t)void 0!==t[r]&&(i[r]=e(t[r]));return i}return t}(t))),s=iC(i),a=new Uint8Array(r?[1]:[0]),p=r?Q(r.slice(2)):new Uint8Array,c=em(ee(o,s,a,p,void 0!==n?new Uint8Array([0]):new Uint8Array,void 0!==n?iC(n):new Uint8Array));return"0x".concat(X(c))}function iC(e){let t=new Uint8Array(8);return new DataView(t.buffer).setBigUint64(0,BigInt(e)),t}async function iB(e){let{wallet:t,action:i,nonce:r,isTestnet:n=!1,vaultAddress:o,expiresAfter:s}=e;return await eS({wallet:t,domain:{name:"Exchange",version:"1",chainId:1337,verifyingContract:"0x0000000000000000000000000000000000000000"},types:{Agent:[{name:"source",type:"string"},{name:"connectionId",type:"bytes32"}]},primaryType:"Agent",message:{source:n?"b":"a",connectionId:iD({action:i,nonce:r,vaultAddress:o,expiresAfter:s})}})}async function iO(e){let{wallet:t,action:i,types:r}=e,n=Object.keys(r)[0];if("approveAgent"!==i.type||i.agentName||(i={...i,agentName:""}),"payloadMultiSigUser"in i&&"outerSigner"in i){let e=r[n];r={...r,[n]:[e[0],{name:"payloadMultiSigUser",type:"address"},{name:"outerSigner",type:"address"},...e.slice(1)]}}let o=new Set(r[n].map(e=>e.name)),s=Object.fromEntries(Object.entries(i).filter(e=>{let[t]=e;return o.has(t)}));return await eS({wallet:t,domain:{name:"HyperliquidSignTransaction",version:"1",chainId:parseInt(i.signatureChainId),verifyingContract:"0x0000000000000000000000000000000000000000"},types:r,primaryType:n,message:s})}async function iR(e){let{wallet:t,action:i,nonce:r,isTestnet:n=!1,vaultAddress:o,expiresAfter:s}=e;if("type"in i){let{type:e,...t}=i;i=t}return await eS({wallet:t,domain:{name:"HyperliquidSignTransaction",version:"1",chainId:parseInt(i.signatureChainId),verifyingContract:"0x0000000000000000000000000000000000000000"},types:{"HyperliquidTransaction:SendMultiSig":[{name:"hyperliquidChain",type:"string"},{name:"multiSigActionHash",type:"bytes32"},{name:"nonce",type:"uint64"}]},primaryType:"HyperliquidTransaction:SendMultiSig",message:{hyperliquidChain:n?"Testnet":"Mainnet",multiSigActionHash:iD({action:i,nonce:r,vaultAddress:o,expiresAfter:s}),nonce:r}})}function iq(e){return"object"==typeof e&&null!==e&&"error"in e&&"string"==typeof e.error}function iL(e){return"object"==typeof e&&null!==e&&"status"in e&&"err"===e.status}!function(e){if(!ih(32))throw Error("padLeft: wrong blockSize=".concat(32));if(!ix(e))throw Error("padLeft: invalid inner value ".concat(e));void 0!==i_&&!1;let t=i_||i_;if(!e.size)throw Error("padLeft cannot have dynamic size");iw({size:e.size+iE(32,e.size),encodeStream:(i,r)=>{let n=iE(32,e.size);for(let e=0;e<n;e++)i.byte(t(e));e.encodeStream(i,r)},decodeStream:t=>(t.bytes(iE(32,e.size)),e.decodeStream(t))})}(iA),!function(e,t){if(e>=256||!Number.isSafeInteger(e))throw Error("Wrong version byte")}(69,e=>("string"==typeof e&&(e=$(e)),ee($("thereum Signed Message:\n".concat(e.length)),e))),new WeakMap,e.s(["ApiRequestError",()=>iP,"assertSuccessResponse",()=>iM],713023);class iP extends t{constructor(e){super(function(e){var t,i,r,n;if(iL(e))return e.response;if(Array.isArray(null==(i=e.response)||null==(t=i.data)?void 0:t.statuses)){let t=e.response.data.statuses.reduce((e,t,i)=>(iq(t)&&e.push("Order ".concat(i,": ").concat(t.error)),e),[]);if(t.length>0)return t.join(", ")}if(iq(null==(n=e.response)||null==(r=n.data)?void 0:r.status))return e.response.data.status.error}(e)||"An unknown error occurred while processing an API request. See `response` for more details."),(0,n._)(this,"response",void 0),this.name="ApiRequestError",this.response=e}}function iM(e){var t,i;if(iL(e)||function(e){var t,i;if("object"!=typeof e||null===e)return!1;let r=null==(i=e.response)||null==(t=i.data)?void 0:t.statuses;return Array.isArray(r)&&r.some(iq)}(e)||"object"==typeof e&&null!==e&&iq(null==(i=e.response)||null==(t=i.data)?void 0:t.status))throw new iP(e)}let iN=new class{getNonce(e){var t;let i=Date.now();this.cleanup(i);let r=null!=(t=this.map.get(e))?t:0,n=i>r?i:r+1;return this.map.set(e,n),n}cleanup(e){for(let[t,i]of this.map)e>i&&this.map.delete(t)}constructor(){(0,n._)(this,"map",new Map)}};var iF=e.i(346200),iV=new WeakMap,iH=new WeakMap,iz=new WeakMap,iW=new WeakMap;class iK{acquire(){return(0,ek._)(this,iH)>0?((0,iF._)(this,iH).value--,Promise.resolve()):new Promise(e=>{let t={res:e,next:void 0};(0,ek._)(this,iW)?(0,eD._)(this,iW,(0,ek._)(this,iW).next=t):(0,eD._)(this,iz,(0,eD._)(this,iW,t))})}release(){(0,ek._)(this,iz)?((0,ek._)(this,iz).res(),(0,eD._)(this,iz,(0,ek._)(this,iz).next),(0,ek._)(this,iz)||(0,eD._)(this,iW,void 0)):(0,ek._)(this,iH)<(0,ek._)(this,iV)&&(0,iF._)(this,iH).value++}constructor(e=1){if((0,ej._)(this,iV,{writable:!0,value:void 0}),(0,ej._)(this,iH,{writable:!0,value:void 0}),(0,ej._)(this,iz,{writable:!0,value:void 0}),(0,ej._)(this,iW,{writable:!0,value:void 0}),e<1)throw TypeError("Cannot create semaphore as 'max' must be at least 1: current value is ".concat(e));(0,eD._)(this,iH,(0,eD._)(this,iV,e))}}var iZ=new WeakMap,iG=new WeakMap;let iX=new class{ref(e){let t=(0,ek._)(this,iZ).get(e);return t||(t={value:(0,ek._)(this,iG).call(this),refs:0},(0,ek._)(this,iZ).set(e,t)),t.refs++,t.value}unref(e){let t=(0,ek._)(this,iZ).get(e);t&&0==--t.refs&&(0,ek._)(this,iZ).delete(e)}constructor(e){(0,ej._)(this,iZ,{writable:!0,value:new Map}),(0,ej._)(this,iG,{writable:!0,value:void 0}),(0,eD._)(this,iG,e)}}(()=>new iK(1));async function iY(e,t){let i=iX.ref(e);await i.acquire();try{return await t()}finally{i.release(),iX.unref(e)}}async function iJ(e,t,i){let{transport:r}=e,n=i2(e),o=await eT(n),s="".concat(o,":").concat(r.isTestnet);return await iY(s,async()=>{var a,p,c,l,d;let u=await (null!=(c=null==(a=e.nonceManager)?void 0:a.call(e,o))?c:iN.getNonce(s)),h=f.parse(f.optional(k.Address),null!=(l=null==i?void 0:i.vaultAddress)?l:e.defaultVaultAddress),g=f.parse(f.optional(k.UnsignedInteger),null!=(d=null==i?void 0:i.expiresAfter)?d:"number"==typeof e.defaultExpiresAfter?e.defaultExpiresAfter:await (null==(p=e.defaultExpiresAfter)?void 0:p.call(e))),b=null==i?void 0:i.signal,[y,m]="wallet"in e?[t,await iB({wallet:n,action:t,nonce:u,isTestnet:r.isTestnet,vaultAddress:h,expiresAfter:g})]:await i0(e,t,o,u,h,g),v=await r.request("exchange",{action:y,signature:m,nonce:u,vaultAddress:h,expiresAfter:g},b);return iM(v),v})}async function iQ(e,t,i,r){let{transport:n}=e,o=i2(e),s=await eT(o),a="".concat(s,":").concat(n.isTestnet);return iY(a,async()=>{var p,c;let l=await (null!=(c=null==(p=e.nonceManager)?void 0:p.call(e,s))?c:iN.getNonce(a)),d=null==r?void 0:r.signal,{type:u,...f}=t,h=function(e){var t;let i=Object.keys(e)[0],r=e[i].find(e=>"nonce"===e.name||"time"===e.name);return null!=(t=null==r?void 0:r.name)?t:"nonce"}(i),g={type:u,signatureChainId:await i8(e),hyperliquidChain:n.isTestnet?"Testnet":"Mainnet",...f,[h]:l},[b,y]="wallet"in e?[g,await iO({wallet:o,action:g,types:i})]:await i1(e,g,i,s,l),m=await n.request("exchange",{action:b,signature:y,nonce:l},d);return iM(m),m})}function i$(e){return{r:e.r.replace(/^0x0+/,"0x"),s:e.s.replace(/^0x0+/,"0x"),v:e.v}}async function i0(e,t,i,r,n,o){let{transport:{isTestnet:s},signers:a,multiSigUser:p}=e,c=f.parse(k.Address,p),l=f.parse(k.Address,i),d=await Promise.all(a.map(async e=>{let i=await iB({wallet:e,action:[c,l,t],nonce:r,isTestnet:s,vaultAddress:n,expiresAfter:o});return i$(i)})),u={type:"multiSig",signatureChainId:await i8(e),signatures:d,payload:{multiSigUser:c,outerSigner:l,action:t}},h=await iR({wallet:a[0],action:u,nonce:r,isTestnet:s,vaultAddress:n,expiresAfter:o});return[u,h]}async function i1(e,t,i,r,n){let{signers:o,multiSigUser:s,transport:{isTestnet:a}}=e,p=f.parse(k.Address,s),c=f.parse(k.Address,r),l=await Promise.all(o.map(async e=>i$(await iO({wallet:e,action:{payloadMultiSigUser:p,outerSigner:c,...t},types:i})))),d={type:"multiSig",signatureChainId:await i8(e),signatures:l,payload:{multiSigUser:p,outerSigner:c,action:t}},u=await iR({wallet:o[0],action:d,nonce:n,isTestnet:a});return[d,u]}function i2(e){return"wallet"in e?e.wallet:e.signers[0]}async function i8(e){if(e.signatureChainId){let t="function"==typeof e.signatureChainId?await e.signatureChainId():e.signatureChainId;return f.parse(k.Hex,t)}return eU(i2(e))}let i3=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("approveAgent"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,agentAddress:f.pipe(k.Address,f.description("Agent address.")),agentName:f.pipe(f.optional(f.nullable(f.string()),null),f.description("Agent name or null for unnamed agent.")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Approve an agent to sign on behalf of the master account.")),i6=f.omit(f.object(i3.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),i4={"HyperliquidTransaction:ApproveAgent":[{name:"hyperliquidChain",type:"string"},{name:"agentAddress",type:"address"},{name:"agentName",type:"string"},{name:"nonce",type:"uint64"}]},i5=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("approveBuilderFee"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,maxFeeRate:f.pipe(k.Percent,f.description('Max fee rate (e.g., "0.01%").')),builder:f.pipe(k.Address,f.description("Builder address.")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Approve a maximum fee rate for a builder.")),i7=f.omit(f.object(i5.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),i9={"HyperliquidTransaction:ApproveBuilderFee":[{name:"hyperliquidChain",type:"string"},{name:"maxFeeRate",type:"string"},{name:"builder",type:"address"},{name:"nonce",type:"uint64"}]},re=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("order"),f.description("Type of action.")),orders:f.pipe(f.array(f.pipe(f.object({a:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),b:f.pipe(f.boolean(),f.description("Position side (`true` for long, `false` for short).")),p:f.pipe(k.UnsignedDecimal,f.description("Price.")),s:f.pipe(k.UnsignedDecimal,f.description("Size (in base currency units).")),r:f.pipe(f.boolean(),f.description("Is reduce-only?")),t:f.pipe(f.union([f.object({limit:f.pipe(f.object({tif:f.pipe(f.picklist(["Gtc","Ioc","Alo","FrontendMarket","LiquidationMarket"]),f.description('Time-in-force.\n- `"Gtc"`: Remains active until filled or canceled.\n- `"Ioc"`: Fills immediately or cancels any unfilled portion.\n- `"Alo"`: Adds liquidity only.\n- `"FrontendMarket"`: Similar to Ioc, used in Hyperliquid UI.\n- `"LiquidationMarket"`: Similar to Ioc, used in Hyperliquid UI.'))}),f.description("Limit order parameters."))}),f.object({trigger:f.pipe(f.object({isMarket:f.pipe(f.boolean(),f.description("Is market order?")),triggerPx:f.pipe(k.UnsignedDecimal,f.description("Trigger price.")),tpsl:f.pipe(f.picklist(["tp","sl"]),f.description("Indicates whether it is take profit or stop loss."))}),f.description("Trigger order parameters."))})]),f.description("Order type.")),c:f.pipe(f.optional(f.pipe(k.Hex,f.length(34))),f.description("Client Order ID."))}),f.description("Place order parameters."))),f.description("Array of order parameters.")),grouping:f.pipe(f.optional(f.picklist(["na","normalTpsl","positionTpsl"]),"na"),f.description("Order grouping strategy:\n- `na`: Standard order without grouping.\n- `normalTpsl`: TP/SL order with fixed size that doesn't adjust with position changes.\n- `positionTpsl`: TP/SL order that adjusts proportionally with the position size.")),builder:f.pipe(f.optional(f.object({b:f.pipe(k.Address,f.description("Builder address.")),f:f.pipe(k.UnsignedInteger,f.description("Builder fee in 0.1bps (1 = 0.0001%)."))})),f.description("Builder fee."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Place an order(s)."));f.pipe(f.object({status:f.pipe(f.literal("ok"),f.description("Successful status.")),response:f.pipe(f.object({type:f.pipe(f.literal("order"),f.description("Type of response.")),data:f.pipe(f.object({statuses:f.pipe(f.array(f.union([f.object({resting:f.pipe(f.object({oid:f.pipe(k.UnsignedInteger,f.description("Order ID.")),cloid:f.pipe(f.optional(f.pipe(k.Hex,f.length(34))),f.description("Client Order ID."))}),f.description("Resting order status."))}),f.object({filled:f.pipe(f.object({totalSz:f.pipe(k.UnsignedDecimal,f.description("Total size filled.")),avgPx:f.pipe(k.UnsignedDecimal,f.description("Average price of fill.")),oid:f.pipe(k.UnsignedInteger,f.description("Order ID.")),cloid:f.pipe(f.optional(f.pipe(k.Hex,f.length(34))),f.description("Client Order ID."))}),f.description("Filled order status."))}),f.object({error:f.pipe(f.string(),f.description("Error message."))})])),f.description("Array of statuses or error messages."))}),f.description("Specific data."))}),f.description("Response details."))}),f.description("Response for order placement."));let rt=f.omit(f.object(re.entries.action.entries),["type"]),ri=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("batchModify"),f.description("Type of action.")),modifies:f.pipe(f.array(f.object({oid:f.pipe(f.union([k.UnsignedInteger,f.pipe(k.Hex,f.length(34))]),f.description("Order ID or Client Order ID.")),order:f.pipe(f.object({a:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),b:f.pipe(f.boolean(),f.description("Position side (`true` for long, `false` for short).")),p:f.pipe(k.UnsignedDecimal,f.description("Price.")),s:f.pipe(k.UnsignedDecimal,f.description("Size (in base currency units).")),r:f.pipe(f.boolean(),f.description("Is reduce-only?")),t:f.pipe(f.union([f.object({limit:f.pipe(f.object({tif:f.pipe(f.picklist(["Gtc","Ioc","Alo","FrontendMarket","LiquidationMarket"]),f.description('Time-in-force.\n- `"Gtc"`: Remains active until filled or canceled.\n- `"Ioc"`: Fills immediately or cancels any unfilled portion.\n- `"Alo"`: Adds liquidity only.\n- `"FrontendMarket"`: Similar to Ioc, used in Hyperliquid UI.\n- `"LiquidationMarket"`: Similar to Ioc, used in Hyperliquid UI.'))}),f.description("Limit order parameters."))}),f.object({trigger:f.pipe(f.object({isMarket:f.pipe(f.boolean(),f.description("Is market order?")),triggerPx:f.pipe(k.UnsignedDecimal,f.description("Trigger price.")),tpsl:f.pipe(f.picklist(["tp","sl"]),f.description("Indicates whether it is take profit or stop loss."))}),f.description("Trigger order parameters."))})]),f.description("Order type.")),c:f.pipe(f.optional(f.pipe(k.Hex,f.length(34))),f.description("Client Order ID."))}),f.description("New order parameters."))})),f.description("Order modifications."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Modify multiple orders.")),rr=f.omit(f.object(ri.entries.action.entries),["type"]),rn=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("cancel"),f.description("Type of action.")),cancels:f.pipe(f.array(f.object({a:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),o:f.pipe(k.UnsignedInteger,f.description("Order ID."))})),f.description("Orders to cancel."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Cancel order(s)."));f.pipe(f.object({status:f.pipe(f.literal("ok"),f.description("Successful status.")),response:f.pipe(f.object({type:f.pipe(f.literal("cancel"),f.description("Type of response.")),data:f.pipe(f.object({statuses:f.pipe(f.array(f.union([f.literal("success"),f.object({error:f.pipe(f.string(),f.description("Error message."))})])),f.description("Array of statuses or error messages."))}),f.description("Specific data."))}),f.description("Response details."))}),f.description("Response for order cancellation."));let ro=f.omit(f.object(rn.entries.action.entries),["type"]),rs=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("cancelByCloid"),f.description("Type of action.")),cancels:f.pipe(f.array(f.object({asset:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),cloid:f.pipe(f.pipe(k.Hex,f.length(34)),f.description("Client Order ID."))})),f.description("Orders to cancel."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Cancel order(s) by cloid.")),ra=f.omit(f.object(rs.entries.action.entries),["type"]),rp=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("cDeposit"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,wei:f.pipe(k.UnsignedInteger,f.description("Amount of wei to deposit into staking balance (float * 1e8).")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Transfer native token from the user spot account into staking for delegating to validators.")),rc=f.omit(f.object(rp.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),rl={"HyperliquidTransaction:CDeposit":[{name:"hyperliquidChain",type:"string"},{name:"wei",type:"uint64"},{name:"nonce",type:"uint64"}]},rd=f.pipe(f.union([f.object({authorizedUsers:f.pipe(f.array(k.Address),f.description("List of authorized user addresses.")),threshold:f.pipe(k.UnsignedInteger,f.description("Minimum number of signatures required."))}),f.pipe(f.null(),f.description("Convert a multi-signature account to a single-signature account."))]),f.description("Signers configuration for `ConvertToMultiSigUserRequest`")),ru=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("convertToMultiSigUser"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,signers:f.pipe(f.union([f.pipe(f.string(),f.parseJson(),rd,f.stringifyJson()),f.pipe(rd,f.stringifyJson())]),f.description("Signers configuration.\n\nMust be `ConvertToMultiSigUserRequestSigners` converted to a string via `JSON.stringify(...)`.")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Convert a single-signature account to a multi-signature account or vice versa.")),rf=f.omit(f.object(ru.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),rh={"HyperliquidTransaction:ConvertToMultiSigUser":[{name:"hyperliquidChain",type:"string"},{name:"signers",type:"string"},{name:"nonce",type:"uint64"}]},rg=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("createSubAccount"),f.description("Type of action.")),name:f.pipe(f.string(),f.minLength(1),f.description("Sub-account name."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Create a sub-account.")),rb=f.omit(f.object(rg.entries.action.entries),["type"]),ry=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("createVault"),f.description("Type of action.")),name:f.pipe(f.string(),f.minLength(3),f.description("Vault name.")),description:f.pipe(f.string(),f.minLength(10),f.description("Vault description.")),initialUsd:f.pipe(k.UnsignedInteger,f.minValue(1e8),f.description("Initial balance (float * 1e6).")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Create a vault.")),rm=f.omit(f.object(ry.entries.action.entries),["type"]),rv=f.pipe(f.object({action:f.pipe(f.union([f.object({type:f.pipe(f.literal("CSignerAction"),f.description("Type of action.")),jailSelf:f.pipe(f.null(),f.description("Jail the signer."))}),f.object({type:f.pipe(f.literal("CSignerAction"),f.description("Type of action.")),unjailSelf:f.pipe(f.null(),f.description("Unjail the signer."))})]),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Jail or unjail self as a validator signer.")),rw=f.union(rv.entries.action.options.map(e=>f.omit(e,["type"]))),rx=f.pipe(f.object({action:f.pipe(f.union([f.object({type:f.pipe(f.literal("CValidatorAction"),f.description("Type of action.")),changeProfile:f.pipe(f.object({node_ip:f.pipe(f.nullable(f.object({Ip:f.pipe(f.string(),f.ip(),f.description("IP address."))})),f.description("Validator node IP address.")),name:f.pipe(f.nullable(f.string()),f.description("Validator name.")),description:f.pipe(f.nullable(f.string()),f.description("Validator description.")),unjailed:f.pipe(f.boolean(),f.description("Validator jail status.")),disable_delegations:f.pipe(f.nullable(f.boolean()),f.description("Enable or disable delegations.")),commission_bps:f.pipe(f.nullable(k.UnsignedInteger),f.description("Commission rate in basis points (1 = 0.0001%).")),signer:f.pipe(f.nullable(k.Address),f.description("Signer address."))}),f.description("Profile changes to apply."))}),f.object({type:f.pipe(f.literal("CValidatorAction"),f.description("Type of action.")),register:f.pipe(f.object({profile:f.pipe(f.object({node_ip:f.pipe(f.object({Ip:f.pipe(f.string(),f.ip(),f.description("IP address."))}),f.description("Validator node IP address.")),name:f.pipe(f.string(),f.description("Validator name.")),description:f.pipe(f.string(),f.description("Validator description.")),delegations_disabled:f.pipe(f.boolean(),f.description("Whether delegations are disabled.")),commission_bps:f.pipe(k.UnsignedInteger,f.description("Commission rate in basis points (1 = 0.0001%).")),signer:f.pipe(k.Address,f.description("Signer address."))}),f.description("Validator profile information.")),unjailed:f.pipe(f.boolean(),f.description("Initial jail status.")),initial_wei:f.pipe(k.UnsignedInteger,f.description("Initial stake amount in wei."))}),f.description("Registration parameters."))}),f.object({type:f.pipe(f.literal("CValidatorAction"),f.description("Type of action.")),unregister:f.pipe(f.null(),f.description("Unregister the validator."))})]),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Action related to validator management.")),rA=f.union(rx.entries.action.options.map(e=>f.omit(e,["type"]))),r_=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("cWithdraw"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,wei:f.pipe(k.UnsignedInteger,f.description("Amount of wei to withdraw from staking balance (float * 1e8).")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Transfer native token from staking into the user's spot account.")),rE=f.omit(f.object(r_.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),rI={"HyperliquidTransaction:CWithdraw":[{name:"hyperliquidChain",type:"string"},{name:"wei",type:"uint64"},{name:"nonce",type:"uint64"}]},rS=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("evmUserModify"),f.description("Type of action.")),usingBigBlocks:f.pipe(f.boolean(),f.description("`true` for large blocks, `false` for small blocks."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Configure block type for EVM transactions.")),rU=f.omit(f.object(rS.entries.action.entries),["type"]),rT=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("linkStakingUser"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,user:f.pipe(k.Address,f.description("Target account address.\n- Trading user initiating: enter staking account address.\n- Staking user finalizing: enter trading account address.")),isFinalize:f.pipe(f.boolean(),f.description("Link phase.\n- `false` = trading user initiates link request.\n- `true` = staking user finalizes permanent link.")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("")),rk=f.omit(f.object(rT.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),rj={"HyperliquidTransaction:LinkStakingUser":[{name:"hyperliquidChain",type:"string"},{name:"user",type:"address"},{name:"isFinalize",type:"bool"},{name:"nonce",type:"uint64"}]},rD=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("modify"),f.description("Type of action.")),oid:f.pipe(f.union([k.UnsignedInteger,f.pipe(k.Hex,f.length(34))]),f.description("Order ID or Client Order ID.")),order:f.pipe(f.object({a:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),b:f.pipe(f.boolean(),f.description("Position side (`true` for long, `false` for short).")),p:f.pipe(k.UnsignedDecimal,f.description("Price.")),s:f.pipe(k.UnsignedDecimal,f.description("Size (in base currency units).")),r:f.pipe(f.boolean(),f.description("Is reduce-only?")),t:f.pipe(f.union([f.object({limit:f.pipe(f.object({tif:f.pipe(f.picklist(["Gtc","Ioc","Alo","FrontendMarket","LiquidationMarket"]),f.description('Time-in-force.\n- `"Gtc"`: Remains active until filled or canceled.\n- `"Ioc"`: Fills immediately or cancels any unfilled portion.\n- `"Alo"`: Adds liquidity only.\n- `"FrontendMarket"`: Similar to Ioc, used in Hyperliquid UI.\n- `"LiquidationMarket"`: Similar to Ioc, used in Hyperliquid UI.'))}),f.description("Limit order parameters."))}),f.object({trigger:f.pipe(f.object({isMarket:f.pipe(f.boolean(),f.description("Is market order?")),triggerPx:f.pipe(k.UnsignedDecimal,f.description("Trigger price.")),tpsl:f.pipe(f.picklist(["tp","sl"]),f.description("Indicates whether it is take profit or stop loss."))}),f.description("Trigger order parameters."))})]),f.description("Order type.")),c:f.pipe(f.optional(f.pipe(k.Hex,f.length(34))),f.description("Client Order ID."))}),f.description("New order parameters."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Modify an order.")),rC=f.omit(f.object(rD.entries.action.entries),["type"]),rB=f.pipe(f.object({action:f.pipe(f.union([f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),registerAsset2:f.pipe(f.object({maxGas:f.pipe(f.nullable(k.UnsignedInteger),f.description(" Max gas in native token wei. If not provided, then uses current deploy auction price.")),assetRequest:f.pipe(f.object({coin:f.pipe(f.string(),f.description("Coin symbol for the new asset.")),szDecimals:f.pipe(k.UnsignedInteger,f.description("Number of decimal places for size.")),oraclePx:f.pipe(k.UnsignedDecimal,f.description("Initial oracle price for the asset.")),marginTableId:f.pipe(k.UnsignedInteger,f.description("Margin table identifier for risk management.")),marginMode:f.pipe(f.picklist(["strictIsolated","noCross"]),f.description("'strictIsolated' does not allow withdrawing of isolated margin from open position."))}),f.description("Contains new asset listing parameters.")),dex:f.pipe(f.string(),f.description("Name of the dex.")),schema:f.pipe(f.nullable(f.object({fullName:f.pipe(f.string(),f.description("Full name of the dex.")),collateralToken:f.pipe(k.UnsignedInteger,f.description("Collateral token index.")),oracleUpdater:f.pipe(f.nullable(k.Address),f.description("User to update oracles. If not provided, then deployer is assumed to be oracle updater."))})),f.description("Contains new dex parameters."))}),f.description("Parameters for registering a new perpetual asset (v2)."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),registerAsset:f.pipe(f.object({maxGas:f.pipe(f.nullable(k.UnsignedInteger),f.description("Max gas in native token wei. If not provided, then uses current deploy auction price.")),assetRequest:f.pipe(f.object({coin:f.pipe(f.string(),f.description("Coin symbol for the new asset.")),szDecimals:f.pipe(k.UnsignedInteger,f.description("Number of decimal places for size.")),oraclePx:f.pipe(k.UnsignedDecimal,f.description("Initial oracle price for the asset.")),marginTableId:f.pipe(k.UnsignedInteger,f.description("Margin table identifier for risk management.")),onlyIsolated:f.pipe(f.boolean(),f.description("Whether the asset can only be traded with isolated margin."))}),f.description("Contains new asset listing parameters.")),dex:f.pipe(f.string(),f.description("Name of the dex.")),schema:f.pipe(f.nullable(f.object({fullName:f.pipe(f.string(),f.description("Full name of the dex.")),collateralToken:f.pipe(k.UnsignedInteger,f.description("Collateral token index.")),oracleUpdater:f.pipe(f.nullable(k.Address),f.description("User to update oracles. If not provided, then deployer is assumed to be oracle updater."))})),f.description("Contains new dex parameters."))}),f.description("Parameters for registering a new perpetual asset."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setOracle:f.pipe(f.object({dex:f.pipe(f.string(),f.minLength(1),f.description("Name of the dex.")),oraclePxs:f.pipe(f.array(f.tuple([f.string(),k.UnsignedDecimal])),f.description("A list (sorted by key) of asset and oracle prices.")),markPxs:f.pipe(f.array(f.array(f.tuple([f.string(),k.UnsignedDecimal]))),f.description("An outer list of inner lists (inner list sorted by key) of asset and mark prices.")),externalPerpPxs:f.pipe(f.array(f.tuple([f.string(),k.UnsignedDecimal])),f.description("A list (sorted by key) of asset and external prices which prevent sudden mark price deviations."))}),f.description("Parameters for setting oracle and mark prices for assets."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setFundingMultipliers:f.pipe(f.array(f.tuple([f.string(),k.UnsignedDecimal])),f.description("A list (sorted by key) of asset and funding multiplier."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),haltTrading:f.pipe(f.object({coin:f.pipe(f.string(),f.description("Coin symbol for the asset to halt or resume.")),isHalted:f.pipe(f.boolean(),f.description("Whether trading should be halted (true) or resumed (false)."))}),f.description("Parameters for halting or resuming trading for an asset."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setMarginTableIds:f.pipe(f.array(f.tuple([f.string(),k.UnsignedInteger])),f.description("A list (sorted by key) of asset and margin table ids."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setFeeRecipient:f.pipe(f.object({dex:f.pipe(f.string(),f.description("Name of the DEX.")),feeRecipient:f.pipe(k.Address,f.description("Address of the fee recipient."))}),f.description("Parameters for setting the fee recipient."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setOpenInterestCaps:f.pipe(f.array(f.tuple([f.string(),k.UnsignedInteger])),f.description("A list (sorted by key) of asset and open interest cap notionals."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setSubDeployers:f.pipe(f.object({dex:f.pipe(f.string(),f.description("Name of the DEX.")),subDeployers:f.pipe(f.array(f.object({variant:f.pipe(f.string(),f.description("Corresponds to a variant of PerpDeployAction.")),user:f.pipe(k.Address,f.description("Sub-deployer address.")),allowed:f.pipe(f.boolean(),f.description("Add or remove the subDeployer from the authorized set for the action variant."))})),f.description("A modification to sub-deployer permissions."))}),f.description("A modification to sub-deployer permissions."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setMarginModes:f.pipe(f.array(f.tuple([f.string(),f.picklist(["strictIsolated","noCross"])])),f.description("A list (sorted by key) of asset and margin modes."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setFeeScale:f.pipe(f.object({dex:f.pipe(f.string(),f.description("Name of the dex.")),scale:f.pipe(k.UnsignedDecimal,f.description("Fee scale (between 0.0 and 3.0)."))}),f.description("Set fee scale."))}),f.object({type:f.pipe(f.literal("perpDeploy"),f.description("Type of action.")),setGrowthModes:f.pipe(f.array(f.tuple([f.string(),f.boolean()])),f.description("A list (sorted by key) of asset and growth modes."))})]),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Deploying HIP-3 assets.")),rO=f.union(rB.entries.action.options.map(e=>f.omit(e,["type"]))),rR=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("registerReferrer"),f.description("Type of action.")),code:f.pipe(f.string(),f.minLength(1),f.description("Referral code to create."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Create a referral code.")),rq=f.omit(f.object(rR.entries.action.entries),["type"]),rL=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("reserveRequestWeight"),f.description("Type of action.")),weight:f.pipe(k.UnsignedInteger,f.description("Amount of request weight to reserve."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Reserve additional rate-limited actions for a fee.")),rP=f.omit(f.object(rL.entries.action.entries),["type"]),rM=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("scheduleCancel"),f.description("Type of action.")),time:f.pipe(f.optional(k.UnsignedInteger),f.description("Scheduled time (in ms since epoch).\nMust be at least 5 seconds in the future.\n\nIf not specified, will cause all scheduled cancel operations to be deleted."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Schedule a cancel-all operation at a future time.")),rN=f.omit(f.object(rM.entries.action.entries),["type"]),rF=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("sendAsset"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,destination:f.pipe(k.Address,f.description("Destination address.")),sourceDex:f.pipe(f.string(),f.description('Source DEX ("" for default USDC perp DEX, "spot" for spot).')),destinationDex:f.pipe(f.string(),f.description('Destination DEX ("" for default USDC perp DEX, "spot" for spot).')),token:f.pipe(k.TokenId,f.description("Token identifier.")),amount:f.pipe(k.UnsignedDecimal,f.description("Amount to send (not in wei).")),fromSubAccount:f.pipe(f.optional(f.union([f.literal(""),k.Address]),""),f.description('Source sub-account address ("" for main account).')),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Transfer tokens between different perp DEXs, spot balance, users, and/or sub-accounts.")),rV=f.omit(f.object(rF.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),rH={"HyperliquidTransaction:SendAsset":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"sourceDex",type:"string"},{name:"destinationDex",type:"string"},{name:"token",type:"string"},{name:"amount",type:"string"},{name:"fromSubAccount",type:"string"},{name:"nonce",type:"uint64"}]},rz=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("setDisplayName"),f.description("Type of action.")),displayName:f.pipe(f.string(),f.description("Display name.\n\nSet to an empty string to remove the display name."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Set the display name in the leaderboard.")),rW=f.omit(f.object(rz.entries.action.entries),["type"]),rK=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("setReferrer"),f.description("Type of action.")),code:f.pipe(f.string(),f.minLength(1),f.description("Referral code."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Set a referral code.")),rZ=f.omit(f.object(rK.entries.action.entries),["type"]),rG=f.pipe(f.object({action:f.pipe(f.union([f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),registerToken2:f.pipe(f.object({spec:f.pipe(f.object({name:f.pipe(f.string(),f.description("Token name.")),szDecimals:f.pipe(k.UnsignedInteger,f.description("Number of decimals for token size.")),weiDecimals:f.pipe(k.UnsignedInteger,f.description("Number of decimals for token amounts in wei."))}),f.description("Token specifications.")),maxGas:f.pipe(k.UnsignedInteger,f.description("Maximum gas allowed for registration.")),fullName:f.pipe(f.optional(f.string()),f.description("Optional full token name."))}),f.description("Register token parameters."))}),f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),userGenesis:f.pipe(f.object({token:f.pipe(k.UnsignedInteger,f.description("Token identifier.")),userAndWei:f.pipe(f.array(f.tuple([k.Address,k.UnsignedDecimal])),f.description("Array of tuples: [user address, genesis amount in wei].")),existingTokenAndWei:f.pipe(f.array(f.tuple([k.UnsignedInteger,k.UnsignedDecimal])),f.description("Array of tuples: [existing token identifier, genesis amount in wei].")),blacklistUsers:f.pipe(f.optional(f.array(f.tuple([k.Address,f.boolean()]))),f.description("Array of tuples: [user address, blacklist status] (`true` for blacklist, `false` to remove existing blacklisted user)."))}),f.description("User genesis parameters."))}),f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),genesis:f.pipe(f.object({token:f.pipe(k.UnsignedInteger,f.description("Token identifier.")),maxSupply:f.pipe(k.UnsignedDecimal,f.description("Maximum token supply.")),noHyperliquidity:f.pipe(f.optional(f.literal(!0)),f.description("Set hyperliquidity balance to 0."))}),f.description("Genesis parameters."))}),f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),registerSpot:f.pipe(f.object({tokens:f.pipe(f.tuple([k.UnsignedInteger,k.UnsignedInteger]),f.description("Tuple containing base and quote token indices."))}),f.description("Register spot parameters."))}),f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),registerHyperliquidity:f.pipe(f.object({spot:f.pipe(k.UnsignedInteger,f.description("Spot index (distinct from base token index).")),startPx:f.pipe(k.UnsignedDecimal,f.description("Starting price for liquidity seeding.")),orderSz:f.pipe(k.UnsignedDecimal,f.description("Order size as a float (not in wei).")),nOrders:f.pipe(k.UnsignedInteger,f.description("Total number of orders to place.")),nSeededLevels:f.pipe(f.optional(k.UnsignedInteger),f.description("Number of levels to seed with USDC."))}),f.description("Register hyperliquidity parameters."))}),f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),setDeployerTradingFeeShare:f.pipe(f.object({token:f.pipe(k.UnsignedInteger,f.description("Token identifier.")),share:f.pipe(k.Percent,f.description("The deployer trading fee share. Range is 0% to 100%."))}),f.description("Set deployer trading fee share parameters."))}),f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),enableQuoteToken:f.pipe(f.object({token:f.pipe(k.UnsignedInteger,f.description("The token ID to convert to a quote token."))}),f.description("Enable quote token parameters."))}),f.object({type:f.pipe(f.literal("spotDeploy"),f.description("Type of action.")),enableAlignedQuoteToken:f.pipe(f.object({token:f.pipe(k.UnsignedInteger,f.description("Token identifier to enable as aligned quote token."))}),f.description("Enable aligned quote token parameters."))})]),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Deploying HIP-1 and HIP-2 assets:\n- Genesis\n- Register Hyperliquidity\n- Register Spot\n- Register Token2\n- Set Deployer Trading Fee Share\n- User Genesis")),rX=f.union(rG.entries.action.options.map(e=>f.omit(e,["type"]))),rY=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("spotSend"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,destination:f.pipe(k.Address,f.description("Destination address.")),token:f.pipe(k.TokenId,f.description("Token identifier.")),amount:f.pipe(k.UnsignedDecimal,f.description("Amount to send (not in wei).")),time:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Send spot assets to another address.")),rJ=f.omit(f.object(rY.entries.action.entries),["type","signatureChainId","hyperliquidChain","time"]),rQ={"HyperliquidTransaction:SpotSend":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"token",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]},r$=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("spotUser"),f.description("Type of action.")),toggleSpotDusting:f.pipe(f.object({optOut:f.pipe(f.boolean(),f.description("Opt out of spot dusting."))}),f.description("Spot dusting options."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Opt Out of Spot Dusting.")),r0=f.omit(f.object(r$.entries.action.entries),["type"]),r1=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("subAccountModify"),f.description("Type of action.")),subAccountUser:f.pipe(k.Address,f.description("Sub-account address to modify.")),name:f.pipe(f.string(),f.minLength(1),f.description("New sub-account name."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Modify a sub-account.")),r2=f.omit(f.object(r1.entries.action.entries),["type"]),r8=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("subAccountSpotTransfer"),f.description("Type of action.")),subAccountUser:f.pipe(k.Address,f.description("Sub-account address.")),isDeposit:f.pipe(f.boolean(),f.description("`true` for deposit, `false` for withdrawal.")),token:f.pipe(k.TokenId,f.description("Token identifier.")),amount:f.pipe(k.UnsignedDecimal,f.description("Amount to send (not in wei)."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Transfer between sub-accounts (spot).")),r3=f.omit(f.object(r8.entries.action.entries),["type"]),r6=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("subAccountTransfer"),f.description("Type of action.")),subAccountUser:f.pipe(k.Address,f.description("Sub-account address.")),isDeposit:f.pipe(f.boolean(),f.description("`true` for deposit, `false` for withdrawal.")),usd:f.pipe(k.UnsignedInteger,f.description("Amount to transfer (float * 1e6)."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Transfer between sub-accounts (perpetual).")),r4=f.omit(f.object(r6.entries.action.entries),["type"]),r5=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("tokenDelegate"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,validator:f.pipe(k.Address,f.description("Validator address.")),wei:f.pipe(k.UnsignedInteger,f.description("Amount for delegate/undelegate (float * 1e8).")),isUndelegate:f.pipe(f.boolean(),f.description("`true` for undelegate, `false` for delegate.")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Delegate or undelegate native tokens to or from a validator.")),r7=f.omit(f.object(r5.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),r9={"HyperliquidTransaction:TokenDelegate":[{name:"hyperliquidChain",type:"string"},{name:"validator",type:"address"},{name:"wei",type:"uint64"},{name:"isUndelegate",type:"bool"},{name:"nonce",type:"uint64"}]},ne=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("twapCancel"),f.description("Type of action.")),a:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),t:f.pipe(k.UnsignedInteger,f.description("Twap ID."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Cancel a TWAP order.")),nt=f.omit(f.object(ne.entries.action.entries),["type"]),ni=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("twapOrder"),f.description("Type of action.")),twap:f.pipe(f.object({a:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),b:f.pipe(f.boolean(),f.description("Position side (`true` for long, `false` for short).")),s:f.pipe(k.UnsignedDecimal,f.description("Size (in base currency units).")),r:f.pipe(f.boolean(),f.description("Is reduce-only?")),m:f.pipe(k.UnsignedInteger,f.description("TWAP duration in minutes.")),t:f.pipe(f.boolean(),f.description("Enable random order timing."))}),f.description("Twap parameters."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Place a TWAP order.")),nr=f.omit(f.object(ni.entries.action.entries),["type"]),nn=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("updateIsolatedMargin"),f.description("Type of action.")),asset:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),isBuy:f.pipe(f.boolean(),f.description("Position side (`true` for long, `false` for short).")),ntli:f.pipe(k.Integer,f.description("Amount to adjust (float * 1e6)."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Add or remove margin from isolated position.")),no=f.omit(f.object(nn.entries.action.entries),["type"]),ns=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("updateLeverage"),f.description("Type of action.")),asset:f.pipe(k.UnsignedInteger,f.description("Asset ID.")),isCross:f.pipe(f.boolean(),f.description("`true` for cross leverage, `false` for isolated leverage.")),leverage:f.pipe(f.pipe(k.UnsignedInteger,f.minValue(1)),f.description("New leverage value."))}),f.description("Action to perform.")),nonce:D,signature:j,vaultAddress:f.pipe(f.optional(k.Address),f.description("Vault address (for vault trading).")),expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Update cross or isolated leverage on a coin.")),na=f.omit(f.object(ns.entries.action.entries),["type"]),np=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("usdClassTransfer"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,amount:f.pipe(k.UnsignedDecimal,f.description("Amount to transfer (1 = $1).")),toPerp:f.pipe(f.boolean(),f.description("`true` for Spot to Perp, `false` for Perp to Spot.")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Transfer funds between Spot account and Perp account.")),nc=f.omit(f.object(np.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),nl={"HyperliquidTransaction:UsdClassTransfer":[{name:"hyperliquidChain",type:"string"},{name:"amount",type:"string"},{name:"toPerp",type:"bool"},{name:"nonce",type:"uint64"}]},nd=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("usdSend"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,destination:f.pipe(k.Address,f.description("Destination address.")),amount:f.pipe(k.UnsignedDecimal,f.description("Amount to send (1 = $1).")),time:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Send usd to another address.")),nu=f.omit(f.object(nd.entries.action.entries),["type","signatureChainId","hyperliquidChain","time"]),nf={"HyperliquidTransaction:UsdSend":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]},nh=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("userDexAbstraction"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,user:f.pipe(k.Address,f.description("User address.")),enabled:f.pipe(f.boolean(),f.description("Whether to enable or disable HIP-3 DEX abstraction.")),nonce:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Enable/disable HIP-3 DEX abstraction.")),ng=f.omit(f.object(nh.entries.action.entries),["type","signatureChainId","hyperliquidChain","nonce"]),nb={"HyperliquidTransaction:UserDexAbstraction":[{name:"hyperliquidChain",type:"string"},{name:"user",type:"address"},{name:"enabled",type:"bool"},{name:"nonce",type:"uint64"}]},ny=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("validatorL1Stream"),f.description("Type of action.")),riskFreeRate:f.pipe(k.UnsignedDecimal,f.description('Risk-free rate as a decimal string (e.g., "0.05" for 5%).'))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Validator vote on risk-free rate for aligned quote asset.")),nm=f.omit(f.object(ny.entries.action.entries),["type"]),nv=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("vaultDistribute"),f.description("Type of action.")),vaultAddress:f.pipe(k.Address,f.description("Vault address.")),usd:f.pipe(k.UnsignedInteger,f.description("Amount to distribute (float * 1e6).\n\nSet to 0 to close the vault."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Distribute funds from a vault between followers.")),nw=f.omit(f.object(nv.entries.action.entries),["type"]),nx=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("vaultModify"),f.description("Type of action.")),vaultAddress:f.pipe(k.Address,f.description("Vault address.")),allowDeposits:f.pipe(f.optional(f.nullable(f.boolean()),null),f.description("Allow deposits from followers.")),alwaysCloseOnWithdraw:f.pipe(f.optional(f.nullable(f.boolean()),null),f.description("Always close positions on withdrawal."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Modify a vault's configuration.")),nA=f.omit(f.object(nx.entries.action.entries),["type"]),n_=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("vaultTransfer"),f.description("Type of action.")),vaultAddress:f.pipe(k.Address,f.description("Vault address.")),isDeposit:f.pipe(f.boolean(),f.description("`true` for deposit, `false` for withdrawal.")),usd:f.pipe(k.UnsignedInteger,f.description("Amount for deposit/withdrawal (float * 1e6)."))}),f.description("Action to perform.")),nonce:D,signature:j,expiresAfter:f.pipe(f.optional(k.UnsignedInteger),f.description("Expiration time of the action."))}),f.description("Deposit or withdraw from a vault.")),nE=f.omit(f.object(n_.entries.action.entries),["type"]),nI=f.pipe(f.object({action:f.pipe(f.object({type:f.pipe(f.literal("withdraw3"),f.description("Type of action.")),signatureChainId:C,hyperliquidChain:B,destination:f.pipe(k.Address,f.description("Destination address.")),amount:f.pipe(k.UnsignedDecimal,f.description("Amount to withdraw (1 = $1).")),time:D}),f.description("Action to perform.")),nonce:D,signature:j}),f.description("Initiate a withdrawal request.")),nS=f.omit(f.object(nI.entries.action.entries),["type","signatureChainId","hyperliquidChain","time"]),nU={"HyperliquidTransaction:Withdraw":[{name:"hyperliquidChain",type:"string"},{name:"destination",type:"string"},{name:"amount",type:"string"},{name:"time",type:"uint64"}]};class nT{agentEnableDexAbstraction(e){return iJ(this.config_,{type:"agentEnableDexAbstraction"},e)}approveAgent(e,t){var i;return i=this.config_,iQ(i,{type:"approveAgent",...f.parse(i6,e)},i4,t)}approveBuilderFee(e,t){var i;return i=this.config_,iQ(i,{type:"approveBuilderFee",...f.parse(i7,e)},i9,t)}batchModify(e,t){var i;return i=this.config_,iJ(i,{type:"batchModify",...f.parse(rr,e)},t)}cancel(e,t){var i;return i=this.config_,iJ(i,{type:"cancel",...f.parse(ro,e)},t)}cancelByCloid(e,t){var i;return i=this.config_,iJ(i,{type:"cancelByCloid",...f.parse(ra,e)},t)}cDeposit(e,t){var i;return i=this.config_,iQ(i,{type:"cDeposit",...f.parse(rc,e)},rl,t)}claimRewards(e){return iJ(this.config_,{type:"claimRewards"},e)}convertToMultiSigUser(e,t){var i;return i=this.config_,iQ(i,{type:"convertToMultiSigUser",...f.parse(rf,e)},rh,t)}createSubAccount(e,t){var i;return i=this.config_,iJ(i,{type:"createSubAccount",...f.parse(rb,e)},t)}createVault(e,t){var i;return i=this.config_,iJ(i,{type:"createVault",...f.parse(rm,e)},t)}cSignerAction(e,t){var i;return i=this.config_,iJ(i,{type:"CSignerAction",...f.parse(rw,e)},t)}cValidatorAction(e,t){var i;return i=this.config_,iJ(i,{type:"CValidatorAction",...f.parse(rA,e)},t)}cWithdraw(e,t){var i;return i=this.config_,iQ(i,{type:"cWithdraw",...f.parse(rE,e)},rI,t)}evmUserModify(e,t){var i;return i=this.config_,iJ(i,{type:"evmUserModify",...f.parse(rU,e)},t)}linkStakingUser(e,t){var i;return i=this.config_,iQ(i,{type:"linkStakingUser",...f.parse(rk,e)},rj,t)}modify(e,t){var i;return i=this.config_,iJ(i,{type:"modify",...f.parse(rC,e)},t)}order(e,t){var i;return i=this.config_,iJ(i,{type:"order",...f.parse(rt,e)},t)}noop(e){return iJ(this.config_,{type:"noop"},e)}perpDeploy(e,t){var i;return i=this.config_,iJ(i,{type:"perpDeploy",...f.parse(rO,e)},t)}registerReferrer(e,t){var i;return i=this.config_,iJ(i,{type:"registerReferrer",...f.parse(rq,e)},t)}reserveRequestWeight(e,t){var i;return i=this.config_,iJ(i,{type:"reserveRequestWeight",...f.parse(rP,e)},t)}scheduleCancel(e,t){let i=e&&"time"in e;var r=this.config_,n=i?e:{};let o=n&&"time"in n,s=o?i?t:e:n;return iJ(r,{type:"scheduleCancel",...f.parse(rN,o?n:{})},s)}sendAsset(e,t){var i;return i=this.config_,iQ(i,{type:"sendAsset",...f.parse(rV,e)},rH,t)}setDisplayName(e,t){var i;return i=this.config_,iJ(i,{type:"setDisplayName",...f.parse(rW,e)},t)}setReferrer(e,t){var i;return i=this.config_,iJ(i,{type:"setReferrer",...f.parse(rZ,e)},t)}spotDeploy(e,t){var i;return i=this.config_,iJ(i,{type:"spotDeploy",...f.parse(rX,e)},t)}spotSend(e,t){var i;return i=this.config_,iQ(i,{type:"spotSend",...f.parse(rJ,e)},rQ,t)}spotUser(e,t){var i;return i=this.config_,iJ(i,{type:"spotUser",...f.parse(r0,e)},t)}subAccountModify(e,t){var i;return i=this.config_,iJ(i,{type:"subAccountModify",...f.parse(r2,e)},t)}subAccountSpotTransfer(e,t){var i;return i=this.config_,iJ(i,{type:"subAccountSpotTransfer",...f.parse(r3,e)},t)}subAccountTransfer(e,t){var i;return i=this.config_,iJ(i,{type:"subAccountTransfer",...f.parse(r4,e)},t)}tokenDelegate(e,t){var i;return i=this.config_,iQ(i,{type:"tokenDelegate",...f.parse(r7,e)},r9,t)}twapCancel(e,t){var i;return i=this.config_,iJ(i,{type:"twapCancel",...f.parse(nt,e)},t)}twapOrder(e,t){var i;return i=this.config_,iJ(i,{type:"twapOrder",...f.parse(nr,e)},t)}updateIsolatedMargin(e,t){var i;return i=this.config_,iJ(i,{type:"updateIsolatedMargin",...f.parse(no,e)},t)}updateLeverage(e,t){var i;return i=this.config_,iJ(i,{type:"updateLeverage",...f.parse(na,e)},t)}usdClassTransfer(e,t){var i;return i=this.config_,iQ(i,{type:"usdClassTransfer",...f.parse(nc,e)},nl,t)}usdSend(e,t){var i;return i=this.config_,iQ(i,{type:"usdSend",...f.parse(nu,e)},nf,t)}userDexAbstraction(e,t){var i;return i=this.config_,iQ(i,{type:"userDexAbstraction",...f.parse(ng,e)},nb,t)}validatorL1Stream(e,t){var i;return i=this.config_,iJ(i,{type:"validatorL1Stream",...f.parse(nm,e)},t)}vaultDistribute(e,t){var i;return i=this.config_,iJ(i,{type:"vaultDistribute",...f.parse(nw,e)},t)}vaultModify(e,t){var i;return i=this.config_,iJ(i,{type:"vaultModify",...f.parse(nA,e)},t)}vaultTransfer(e,t){var i;return i=this.config_,iJ(i,{type:"vaultTransfer",...f.parse(nE,e)},t)}withdraw3(e,t){var i;return i=this.config_,iQ(i,{type:"withdraw3",...f.parse(nS,e)},nU,t)}constructor(e){(0,n._)(this,"config_",void 0),this.config_=e}}e.s(["InfoClient",()=>oC],177558);var nk=e.i(24287),nj=e.i(373912),nD=e.i(969641),nC=e.i(878330),nB=e.i(22187),nO=e.i(949770),nR=e.i(381256),nq=e.i(121885),nL=e.i(910509),nP=e.i(719371),nM=e.i(893128),nN=e.i(378856),nF=e.i(54549),nV=e.i(536175),nH=e.i(49445),nz=e.i(189121),nW=e.i(238888),nK=e.i(775774),nZ=e.i(726558),nG=e.i(47360),nX=e.i(212452),nY=e.i(421914),nJ=e.i(564827),nQ=e.i(171816),n$=e.i(666446),n0=e.i(598706),n1=e.i(363957),n2=e.i(510249),n8=e.i(267516),n3=e.i(661685),n6=e.i(170303),n4=e.i(41501),n5=e.i(552948),n7=e.i(901101),n9=e.i(286077),oe=e.i(742342),ot=e.i(668264),oi=e.i(272018),or=e.i(532578),on=e.i(732694),oo=e.i(676001),os=e.i(753726),oa=e.i(769598),op=e.i(984358),oc=e.i(191436),ol=e.i(382488),od=e.i(135194),ou=e.i(918934),of=e.i(32237),oh=e.i(40744),og=e.i(581475),ob=e.i(204053),oy=e.i(297516),om=e.i(788349),ov=e.i(331179),ow=e.i(182569),ox=e.i(291049),oA=e.i(22277),o_=e.i(886360),oE=e.i(405939),oI=e.i(195977),oS=e.i(281839),oU=e.i(282535),oT=e.i(416618),ok=e.i(943133),oj=e.i(588995),oD=e.i(715134);class oC{activeAssetData(e,t){return(0,nk.activeAssetData)(this.config_,e,t)}alignedQuoteTokenInfo(e,t){return(0,nj.alignedQuoteTokenInfo)(this.config_,e,t)}allMids(e,t){let i=e instanceof AbortSignal?{}:e,r=e instanceof AbortSignal?e:t;return(0,nD.allMids)(this.config_,i,r)}allPerpMetas(e){return(0,nC.allPerpMetas)(this.config_,e)}blockDetails(e,t){return(0,nB.blockDetails)(this.config_,e,t)}candleSnapshot(e,t){return(0,nO.candleSnapshot)(this.config_,e,t)}clearinghouseState(e,t){return(0,nR.clearinghouseState)(this.config_,e,t)}delegations(e,t){return(0,nq.delegations)(this.config_,e,t)}delegatorHistory(e,t){return(0,nL.delegatorHistory)(this.config_,e,t)}delegatorRewards(e,t){return(0,nP.delegatorRewards)(this.config_,e,t)}delegatorSummary(e,t){return(0,nM.delegatorSummary)(this.config_,e,t)}exchangeStatus(e){return(0,nN.exchangeStatus)(this.config_,e)}extraAgents(e,t){return(0,nF.extraAgents)(this.config_,e,t)}frontendOpenOrders(e,t){return(0,nV.frontendOpenOrders)(this.config_,e,t)}fundingHistory(e,t){return(0,nH.fundingHistory)(this.config_,e,t)}gossipRootIps(e){return(0,nz.gossipRootIps)(this.config_,e)}historicalOrders(e,t){return(0,nW.historicalOrders)(this.config_,e,t)}isVip(e,t){return(0,nK.isVip)(this.config_,e,t)}l2Book(e,t){return(0,nZ.l2Book)(this.config_,e,t)}leadingVaults(e,t){return(0,nG.leadingVaults)(this.config_,e,t)}legalCheck(e,t){return(0,nX.legalCheck)(this.config_,e,t)}liquidatable(e){return(0,nY.liquidatable)(this.config_,e)}marginTable(e,t){return(0,nJ.marginTable)(this.config_,e,t)}maxBuilderFee(e,t){return(0,nQ.maxBuilderFee)(this.config_,e,t)}maxMarketOrderNtls(e){return(0,n$.maxMarketOrderNtls)(this.config_,e)}meta(e,t){let i=e instanceof AbortSignal?{}:e,r=e instanceof AbortSignal?e:t;return(0,n0.meta)(this.config_,i,r)}metaAndAssetCtxs(e,t){let i=e instanceof AbortSignal?{}:e,r=e instanceof AbortSignal?e:t;return(0,n1.metaAndAssetCtxs)(this.config_,i,r)}openOrders(e,t){return(0,n2.openOrders)(this.config_,e,t)}orderStatus(e,t){return(0,n8.orderStatus)(this.config_,e,t)}perpDeployAuctionStatus(e){return(0,n3.perpDeployAuctionStatus)(this.config_,e)}perpDexLimits(e,t){return(0,n6.perpDexLimits)(this.config_,e,t)}perpDexs(e){return(0,n4.perpDexs)(this.config_,e)}perpDexStatus(e,t){return(0,n5.perpDexStatus)(this.config_,e,t)}perpsAtOpenInterestCap(e,t){let i=e instanceof AbortSignal?{}:e,r=e instanceof AbortSignal?e:t;return(0,n7.perpsAtOpenInterestCap)(this.config_,i,r)}portfolio(e,t){return(0,n9.portfolio)(this.config_,e,t)}predictedFundings(e){return(0,oe.predictedFundings)(this.config_,e)}preTransferCheck(e,t){return(0,ot.preTransferCheck)(this.config_,e,t)}recentTrades(e,t){return(0,oi.recentTrades)(this.config_,e,t)}referral(e,t){return(0,or.referral)(this.config_,e,t)}spotClearinghouseState(e,t){return(0,on.spotClearinghouseState)(this.config_,e,t)}spotDeployState(e,t){return(0,oo.spotDeployState)(this.config_,e,t)}spotMeta(e){return(0,os.spotMeta)(this.config_,e)}spotMetaAndAssetCtxs(e){return(0,oa.spotMetaAndAssetCtxs)(this.config_,e)}spotPairDeployAuctionStatus(e){return(0,op.spotPairDeployAuctionStatus)(this.config_,e)}subAccounts(e,t){return(0,oc.subAccounts)(this.config_,e,t)}subAccounts2(e,t){return(0,ol.subAccounts2)(this.config_,e,t)}tokenDetails(e,t){return(0,od.tokenDetails)(this.config_,e,t)}twapHistory(e,t){return(0,ou.twapHistory)(this.config_,e,t)}txDetails(e,t){return(0,of.txDetails)(this.config_,e,t)}userDetails(e,t){return(0,oh.userDetails)(this.config_,e,t)}userDexAbstraction(e,t){return(0,og.userDexAbstraction)(this.config_,e,t)}userFees(e,t){return(0,ob.userFees)(this.config_,e,t)}userFills(e,t){return(0,oy.userFills)(this.config_,e,t)}userFillsByTime(e,t){return(0,om.userFillsByTime)(this.config_,e,t)}userFunding(e,t){return(0,ov.userFunding)(this.config_,e,t)}userNonFundingLedgerUpdates(e,t){return(0,ow.userNonFundingLedgerUpdates)(this.config_,e,t)}userRateLimit(e,t){return(0,ox.userRateLimit)(this.config_,e,t)}userRole(e,t){return(0,oA.userRole)(this.config_,e,t)}userToMultiSigSigners(e,t){return(0,o_.userToMultiSigSigners)(this.config_,e,t)}userTwapSliceFills(e,t){return(0,oE.userTwapSliceFills)(this.config_,e,t)}userTwapSliceFillsByTime(e,t){return(0,oI.userTwapSliceFillsByTime)(this.config_,e,t)}userVaultEquities(e,t){return(0,oS.userVaultEquities)(this.config_,e,t)}validatorL1Votes(e){return(0,oU.validatorL1Votes)(this.config_,e)}validatorSummaries(e){return(0,oT.validatorSummaries)(this.config_,e)}vaultDetails(e,t){return(0,ok.vaultDetails)(this.config_,e,t)}vaultSummaries(e){return(0,oj.vaultSummaries)(this.config_,e)}webData2(e,t){return(0,oD.webData2)(this.config_,e,t)}constructor(e){(0,n._)(this,"config_",void 0),this.config_=e}}e.s(["SubscriptionClient",()=>o5],152634);let oB=f.pipe(f.object({type:f.pipe(f.literal("activeAssetCtx"),f.description("Type of subscription.")),coin:f.pipe(f.string(),f.description("Asset symbol (e.g., BTC)."))}),f.description("Subscription to context events for a specific perpetual asset.")),oO=f.pipe(f.object({type:f.pipe(f.literal("activeAssetData"),f.description("Type of subscription.")),coin:f.pipe(f.string(),f.description("Asset symbol (e.g., BTC).")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to active asset data events for a specific user and coin.")),oR=f.pipe(f.object({type:f.pipe(f.literal("activeAssetCtx"),f.description("Type of subscription.")),coin:f.pipe(f.string(),f.description("Asset ID (e.g., @1)."))}),f.description("Subscription to context events for a specific spot asset.")),oq=f.pipe(f.object({type:f.pipe(f.literal("allDexsAssetCtxs"),f.description("Type of subscription."))}),f.description("Subscription to asset context events for all DEXs.")),oL=f.pipe(f.object({type:f.pipe(f.literal("allDexsClearinghouseState"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to clearinghouse state events for all DEXs for a specific user.")),oP=f.pipe(f.object({type:f.pipe(f.literal("allMids"),f.description("Type of subscription.")),dex:f.pipe(f.optional(f.string()),f.description("DEX name (empty string for main dex)."))}),f.description("Subscription to mid price events for all coins.")),oM=f.pipe(f.object({type:f.pipe(f.literal("assetCtxs"),f.description("Type of subscription.")),dex:f.pipe(f.optional(f.string()),f.description("DEX name (empty string for main dex)."))}),f.description("Subscription to context events for all perpetual assets.")),oN=f.pipe(f.object({type:f.pipe(f.literal("bbo"),f.description("Type of subscription.")),coin:f.pipe(f.string(),f.description("Asset symbol (e.g., BTC)."))}),f.description("Subscription to best bid and offer events for a specific asset."));f.pipe(f.object({px:f.pipe(k.UnsignedDecimal,f.description("Price.")),sz:f.pipe(k.UnsignedDecimal,f.description("Total size.")),n:f.pipe(k.UnsignedInteger,f.description("Number of individual orders."))}),f.description("L2 order book level."));let oF=f.pipe(f.object({type:f.pipe(f.literal("candle"),f.description("Type of subscription.")),coin:f.pipe(f.string(),f.description("Asset symbol (e.g., BTC).")),interval:f.pipe(f.picklist(["1m","3m","5m","15m","30m","1h","2h","4h","8h","12h","1d","3d","1w","1M"]),f.description("Time interval."))}),f.description("Subscription to candlestick events for a specific asset and time interval.")),oV=f.pipe(f.object({type:f.pipe(f.literal("clearinghouseState"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address.")),dex:f.pipe(f.optional(f.string()),f.description("DEX name (empty string for main dex)."))}),f.description("Subscription to clearinghouse state events for a specific user.")),oH=f.pipe(f.object({type:f.pipe(f.literal("explorerBlock"),f.description("Type of subscription."))}),f.description("Subscription to explorer block events.")),oz=f.pipe(f.object({type:f.pipe(f.literal("explorerTxs"),f.description("Type of subscription."))}),f.description("Subscription to explorer transaction events.")),oW=f.pipe(f.object({type:f.pipe(f.literal("l2Book"),f.description("Type of subscription.")),coin:f.pipe(f.string(),f.description("Asset symbol (e.g., BTC).")),nSigFigs:f.pipe(f.nullish(f.pipe(k.Integer,f.picklist([2,3,4,5]))),f.description("Number of significant figures.")),mantissa:f.pipe(f.nullish(f.pipe(k.Integer,f.picklist([2,5]))),f.description("Mantissa for aggregation (if `nSigFigs` is 5)."))}),f.description("Subscription to L2 order book events for a specific asset."));f.pipe(f.object({px:f.pipe(k.UnsignedDecimal,f.description("Price.")),sz:f.pipe(k.UnsignedDecimal,f.description("Total size.")),n:f.pipe(k.UnsignedInteger,f.description("Number of individual orders."))}),f.description("L2 order book level."));let oK=f.pipe(f.object({type:f.pipe(f.literal("notification"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to notification events for a specific user.")),oZ=f.pipe(f.object({type:f.pipe(f.literal("openOrders"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address.")),dex:f.pipe(f.optional(f.string()),f.description("DEX name (empty string for main dex)."))}),f.description("Subscription to open order events for a specific user.")),oG=f.pipe(f.object({type:f.pipe(f.literal("orderUpdates"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to order updates for a specific user.")),oX=f.pipe(f.object({type:f.pipe(f.literal("spotAssetCtxs"),f.description("Type of subscription."))}),f.description("Subscription to context events for all spot assets.")),oY=f.pipe(f.object({type:f.pipe(f.literal("spotState"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address.")),ignorePortfolioMargin:f.pipe(f.optional(f.boolean(),!1),f.description("Whether to ignore portfolio margin calculations."))}),f.description("Subscription to spot state events for a specific user.")),oJ=f.pipe(f.object({type:f.pipe(f.literal("trades"),f.description("Type of subscription.")),coin:f.pipe(f.string(),f.description("Asset symbol (e.g., BTC)."))}),f.description("Subscription to trade events for a specific asset.")),oQ=f.pipe(f.object({type:f.pipe(f.literal("userEvents"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to user events for a specific user.")),o$=f.pipe(f.object({type:f.pipe(f.literal("userFills"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address.")),aggregateByTime:f.pipe(f.optional(f.boolean()),f.description("If true, partial fills are aggregated when a crossing order fills multiple resting orders."))}),f.description("Subscription to user fill events for a specific user.")),o0=f.pipe(f.object({type:f.pipe(f.literal("userFundings"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to user funding events for a specific user.")),o1=f.pipe(f.object({type:f.pipe(f.literal("userHistoricalOrders"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to user historical orders for a specific user.")),o2=f.pipe(f.object({type:f.pipe(f.literal("userNonFundingLedgerUpdates"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to user non-funding ledger updates for a specific user.")),o8=f.pipe(f.object({type:f.pipe(f.literal("userTwapHistory"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to user TWAP history events for a specific user.")),o3=f.pipe(f.object({type:f.pipe(f.literal("userTwapSliceFills"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to user TWAP slice fill events for a specific user.")),o6=f.pipe(f.object({type:f.pipe(f.literal("webData2"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to comprehensive user and market data events.")),o4=f.pipe(f.object({type:f.pipe(f.literal("webData3"),f.description("Type of subscription.")),user:f.pipe(k.Address,f.description("User address."))}),f.description("Subscription to comprehensive user and market data events."));class o5{activeAssetCtx(e,t){var i=this.config_;let r=f.parse(oB,{type:"activeAssetCtx",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.coin===r.coin&&t(e.detail)})}activeAssetData(e,t){var i=this.config_;let r=f.parse(oO,{type:"activeAssetData",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.coin===r.coin&&e.detail.user===r.user&&t(e.detail)})}activeSpotAssetCtx(e,t){var i=this.config_;let r=f.parse(oR,{type:"activeAssetCtx",...e});return i.transport.subscribe("activeSpotAssetCtx",r,e=>{e.detail.coin===r.coin&&t(e.detail)})}allDexsAssetCtxs(e){var t=this.config_;let i=f.parse(oq,{type:"allDexsAssetCtxs"});return t.transport.subscribe(i.type,i,t=>{e(t.detail)})}allDexsClearinghouseState(e,t){var i=this.config_;let r=f.parse(oL,{type:"allDexsClearinghouseState",...e});return i.transport.subscribe(r.type,r,e=>{t(e.detail)})}allMids(e,t){let i="function"==typeof e?{}:e,r="function"==typeof e?e:t;return function(e,t,i){let r="function"==typeof t?{}:t,n="function"==typeof t?t:i,o=f.parse(oP,{type:"allMids",...r,dex:r.dex||void 0});return e.transport.subscribe(o.type,o,e=>{e.detail.dex===o.dex&&n(e.detail)})}(this.config_,i,r)}assetCtxs(e,t){let i="function"==typeof e?{}:e,r="function"==typeof e?e:t;return function(e,t,i){var r;let n="function"==typeof t?{}:t,o="function"==typeof t?t:i,s=f.parse(oM,{type:"assetCtxs",...n,dex:null!=(r=n.dex)?r:""});return e.transport.subscribe(s.type,s,e=>{e.detail.dex===s.dex&&o(e.detail)})}(this.config_,i,r)}bbo(e,t){var i=this.config_;let r=f.parse(oN,{type:"bbo",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.coin===r.coin&&t(e.detail)})}candle(e,t){var i=this.config_;let r=f.parse(oF,{type:"candle",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.s===r.coin&&e.detail.i===r.interval&&t(e.detail)})}clearinghouseState(e,t){var i,r=this.config_;let n=f.parse(oV,{type:"clearinghouseState",...e,dex:null!=(i=e.dex)?i:""});return r.transport.subscribe(n.type,n,e=>{e.detail.user===n.user&&e.detail.dex===n.dex&&t(e.detail)})}explorerBlock(e){var t=this.config_;let i=f.parse(oH,{type:"explorerBlock"});return t.transport.subscribe("_explorerBlock",i,t=>{e(t.detail)})}explorerTxs(e){var t=this.config_;let i=f.parse(oz,{type:"explorerTxs"});return t.transport.subscribe("_explorerTxs",i,t=>{e(t.detail)})}l2Book(e,t){return function(e,t,i){var r,n;let o=f.parse(oW,{type:"l2Book",...t,nSigFigs:null!=(r=t.nSigFigs)?r:null,mantissa:null!=(n=t.mantissa)?n:null});return e.transport.subscribe(o.type,o,e=>{e.detail.coin===o.coin&&i(e.detail)})}(this.config_,e,t)}notification(e,t){var i=this.config_;let r=f.parse(oK,{type:"notification",...e});return i.transport.subscribe(r.type,r,e=>{t(e.detail)})}openOrders(e,t){var i,r=this.config_;let n=f.parse(oZ,{type:"openOrders",...e,dex:null!=(i=e.dex)?i:""});return r.transport.subscribe(n.type,n,e=>{e.detail.user===n.user&&e.detail.dex===n.dex&&t(e.detail)})}orderUpdates(e,t){var i=this.config_;let r=f.parse(oG,{type:"orderUpdates",...e});return i.transport.subscribe(r.type,r,e=>{t(e.detail)})}spotAssetCtxs(e){var t=this.config_;let i=f.parse(oX,{type:"spotAssetCtxs"});return t.transport.subscribe(i.type,i,t=>{e(t.detail)})}spotState(e,t){var i=this.config_;let r=f.parse(oY,{type:"spotState",user:e.user});return i.transport.subscribe(r.type,r,e=>{e.detail.user===r.user&&t(e.detail)})}trades(e,t){var i=this.config_;let r=f.parse(oJ,{type:"trades",...e});return i.transport.subscribe(r.type,r,e=>{var i;(null==(i=e.detail[0])?void 0:i.coin)===r.coin&&t(e.detail)})}userEvents(e,t){var i=this.config_;let r=f.parse(oQ,{type:"userEvents",...e});return i.transport.subscribe("user",r,e=>{t(e.detail)})}userFills(e,t){var i,r=this.config_;let n=f.parse(o$,{type:"userFills",...e,aggregateByTime:null!=(i=e.aggregateByTime)&&i});return r.transport.subscribe(n.type,n,e=>{e.detail.user===n.user&&t(e.detail)})}userFundings(e,t){var i=this.config_;let r=f.parse(o0,{type:"userFundings",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.user===r.user&&t(e.detail)})}userHistoricalOrders(e,t){var i=this.config_;let r=f.parse(o1,{type:"userHistoricalOrders",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.user===r.user&&t(e.detail)})}userNonFundingLedgerUpdates(e,t){var i=this.config_;let r=f.parse(o2,{type:"userNonFundingLedgerUpdates",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.user===r.user&&t(e.detail)})}userTwapHistory(e,t){var i=this.config_;let r=f.parse(o8,{type:"userTwapHistory",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.user===r.user&&t(e.detail)})}userTwapSliceFills(e,t){var i=this.config_;let r=f.parse(o3,{type:"userTwapSliceFills",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.user===r.user&&t(e.detail)})}webData2(e,t){var i=this.config_;let r=f.parse(o6,{type:"webData2",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.user===r.user&&t(e.detail)})}webData3(e,t){var i=this.config_;let r=f.parse(o4,{type:"webData3",...e});return i.transport.subscribe(r.type,r,e=>{e.detail.userState.user===r.user&&t(e.detail)})}constructor(e){(0,n._)(this,"config_",void 0),this.config_=e}}},95556,608787,e=>{"use strict";e.s(["WebSocketTransport",()=>t.WebSocketTransport],95556);var t=e.i(401855);e.i(753586),e.s(["ApiRequestError",()=>r.ApiRequestError,"ExchangeClient",()=>i.ExchangeClient],608787);var i=e.i(984345),r=e.i(713023)},918995,e=>{"use strict";e.s(["privateKeyToAccount",()=>m],918995);var t=e.i(300059),i=e.i(265710),r=e.i(945895),n=e.i(548485),o=e.i(378431),s=e.i(909961),a=e.i(822164);async function p(e){let{hash:r,privateKey:n,to:p="object"}=e,{r:c,s:l,recovery:d}=t.secp256k1.sign(r.slice(2),n.slice(2),{lowS:!0,extraEntropy:!!(0,o.isHex)(!1,{strict:!1})&&(0,s.hexToBytes)(!1)}),u={r:(0,i.numberToHex)(c,{size:32}),s:(0,i.numberToHex)(l,{size:32}),v:d?28n:27n,yParity:d};return"bytes"===p||"hex"===p?(0,a.serializeSignature)({...u,to:p}):u}var c=e.i(403877);async function l(e){var t;let{chainId:i,nonce:r,privateKey:n,to:o="object"}=e,s=null!=(t=e.contractAddress)?t:e.address,a=await p({hash:(0,c.hashAuthorization)({address:s,chainId:i,nonce:r}),privateKey:n,to:o});return"object"===o?{address:s,chainId:i,nonce:r,...a}:a}var d=e.i(771613);async function u(e){let{message:t,privateKey:i}=e;return await p({hash:(0,d.hashMessage)(t),privateKey:i,to:"hex"})}var f=e.i(392019),h=e.i(128174);async function g(e){let{privateKey:t,transaction:i,serializer:r=h.serializeTransaction}=e,n="eip4844"===i.type?{...i,sidecars:!1}:i,o=await p({hash:(0,f.keccak256)(r(n)),privateKey:t});return r(i,o)}var b=e.i(953850);async function y(e){let{privateKey:t,...i}=e;return await p({hash:(0,b.hashTypedData)(i),privateKey:t,to:"hex"})}function m(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{nonceManager:s}=o,a=(0,i.toHex)(t.secp256k1.getPublicKey(e.slice(2),!1)),c=(0,n.publicKeyToAddress)(a);return{...(0,r.toAccount)({address:c,nonceManager:s,async sign(t){let{hash:i}=t;return p({hash:i,privateKey:e,to:"hex"})},signAuthorization:async t=>l({...t,privateKey:e}),async signMessage(t){let{message:i}=t;return u({message:i,privateKey:e})},async signTransaction(t){let{serializer:i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return g({privateKey:e,transaction:t,serializer:i})},signTypedData:async t=>y({...t,privateKey:e})}),publicKey:a,source:"privateKey"}}},783935,e=>{"use strict";e.s(["useWalletClient",()=>d],783935);var t=e.i(987830),i=e.i(475345),r=e.i(238577);async function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(await (0,r.getConnectorClient)(e,t)).extend(i.walletActions)}var o=e.i(656439),s=e.i(969498),a=e.i(506233),p=e.i(803632),c=e.i(515028),l=e.i(441220);function d(){var e,i,r,d;let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{query:f={},...h}=u,g=(0,l.useConfig)(h),b=(0,t.useQueryClient)(),{address:y,connector:m,status:v}=(0,p.useAccount)({config:g}),w=(0,c.useChainId)({config:g}),x=null!=(e=u.connector)?e:m,{queryKey:A,..._}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return{gcTime:0,async queryFn(i){let{queryKey:r}=i,{connector:o}=t,{connectorUid:s,scopeKey:a,...p}=r[1];return n(e,{...p,connector:o})},queryKey:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{connector:t,...i}=e;return["walletClient",{...(0,o.filterQueryOptions)(i),connectorUid:null==t?void 0:t.uid}]}(t)}}(g,{...u,chainId:null!=(i=u.chainId)?i:w,connector:null!=(r=u.connector)?r:m}),E=!!(("connected"===v||"reconnecting"===v&&(null==x?void 0:x.getProvider))&&(null==(d=f.enabled)||d)),I=(0,s.useRef)(y);return(0,s.useEffect)(()=>{let e=I.current;!y&&e?(b.removeQueries({queryKey:A}),I.current=void 0):y!==e&&(b.invalidateQueries({queryKey:A}),I.current=y)},[y,b]),(0,a.useQuery)({...f,..._,queryKey:A,enabled:E,staleTime:1/0})}},866504,614881,697030,e=>{"use strict";e.s(["useHyperliquidInfoStore",()=>A],866504),e.i(714768);var t=e.i(177558),i=e.i(92687),r=e.i(595273),n=e.i(249023);e.s(["AGENT_NAME",()=>b,"BUILDER_ADDRESS",()=>f,"BUILDER_FEE_BASIS_POINTS",()=>g,"BUILDER_MAX_FEE_RATE",()=>h,"HYPERLIQUID_PRIVATE_KEY_EXPIRY_MS",()=>o,"LEVERAGE_SLIDER_MIN",()=>s,"LEVERAGE_SLIDER_STEP",()=>a,"MARKET_CLOSE_ORDER_SLIPPAGE_MULTIPLIER",()=>c,"MARKET_ORDER_SLIPPAGE_MULTIPLIER",()=>p,"TABLE_SKELETON_ROW_COUNT",()=>l,"TRADES_TABLE_DISPLAY_LIMIT",()=>d,"VALIDATION_ERROR",()=>u],614881);let o=6048e5,s=1,a=1,p=8,c=8,l=10,d=23,u={INVALID_SIZE:"invalidSize",INVALID_LIMIT_PRICE:"invalidLimitPrice",INVALID_STOP_PRICE:"invalidStopPrice"},f="0xc2D921DA88D3D5E718CF97aA9aFB5B35D821918C",h="0.1%",g=50,b="opensea";e.s(["DEFAULT_RESOLUTION",()=>w,"DEFAULT_TV_RESOLUTION",()=>x,"RESOLUTION_TO_TV",()=>y,"SUPPORTED_RESOLUTIONS",()=>v,"TV_TO_RESOLUTION",()=>m],697030);let y={"1m":"1","3m":"3","5m":"5","15m":"15","30m":"30","1h":"60","2h":"120","4h":"240","8h":"480","12h":"720","1d":"1D","3d":"3D","1w":"1W","1M":"1M"},m={1:"1m",3:"3m",5:"5m",15:"15m",30:"30m",60:"1h",120:"2h",240:"4h",480:"8h",720:"12h","1D":"1d",D:"1d","3D":"3d","1W":"1w",W:"1w","1M":"1M",M:"1M"},v=Object.values(y),w="15m",x=y[w],A=(0,r.create)()((0,n.persist)((e,r)=>({privateKeys:{},setPrivateKey:(t,i)=>{let r=t.toLowerCase();e(e=>{let t={...e.privateKeys};return i?t[r]={privateKey:i,createdAt:Date.now()}:delete t[r],{privateKeys:t}})},getPrivateKey:e=>{var t,i;return e&&null!=(i=null==(t=r().privateKeys[e.toLowerCase()])?void 0:t.privateKey)?i:null},fetchAndStorePerpetualInfo:async()=>{try{var r,n,o;let s=new t.InfoClient({transport:new i.HttpTransport}),a=null!=(r=(await s.meta()).universe)?r:[],p={};for(let e=0;e<a.length;e+=1){let t=a[e];(null==t?void 0:t.name)&&(p[t.name]={assetId:e,szDecimals:t.szDecimals,name:t.name,maxLeverage:t.maxLeverage,marginTableId:t.marginTableId,isDelisted:null!=(n=t.isDelisted)&&n,onlyIsolated:null!=(o=t.onlyIsolated)&&o})}e({perpetualInfo:p})}catch(e){throw console.error("Failed to fetch Hyperliquid meta:",e),e}},isApprovePerpetualAgentModalOpen:!1,setIsApprovePerpetualAgentModalOpen:t=>{e({isApprovePerpetualAgentModalOpen:t})},perpetualInfo:{},setPerpetualInfo:t=>{e({perpetualInfo:t})},marketOrderSlippageMultiplierPercent:p,setMarketOrderSlippageMultiplierPercent:t=>{e({marketOrderSlippageMultiplierPercent:t})},tradingviewResolution:w,setTradingviewResolution:t=>{e({tradingviewResolution:t})},tpslVariant:"percent",setTpslVariant:t=>{e({tpslVariant:t})},collateralPresetMode:"usd",setCollateralPresetMode:t=>{e({collateralPresetMode:t})},orderBookUnit:"USDC",setOrderBookUnit:t=>{e({orderBookUnit:t})},isOrderBookExpanded:!0,setIsOrderBookExpanded:t=>{e({isOrderBookExpanded:t})}}),{name:"hyperliquidinfo",partialize:e=>({privateKeys:e.privateKeys,perpetualInfo:e.perpetualInfo,marketOrderSlippageMultiplierPercent:e.marketOrderSlippageMultiplierPercent,tradingviewResolution:e.tradingviewResolution,tpslVariant:e.tpslVariant,collateralPresetMode:e.collateralPresetMode,orderBookUnit:e.orderBookUnit,isOrderBookExpanded:e.isOrderBookExpanded})}))},963724,e=>{"use strict";e.s(["setHyperliquidPrivateKey",()=>h,"useHyperliquidClients",()=>g]),e.i(714768);var t=e.i(92687),i=e.i(95556),r=e.i(177558),n=e.i(152634),o=e.i(608787),s=e.i(798030),a=e.i(969498),p=e.i(918995),c=e.i(783935),l=e.i(614881),d=e.i(866504);let u={http:null,ws:null},f={info:null,subscription:null,lastWalletAddress:null,wallet:void 0};function h(e,t){d.useHyperliquidInfoStore.getState().setPrivateKey(e,t)}function g(){var e,h,g,b,y;let m=(0,c.useWalletClient)(),v=null==(g=m.data)||null==(h=g.account)||null==(e=h.address)?void 0:e.toLowerCase(),w=(0,d.useHyperliquidInfoStore)(e=>{var t;return v&&null!=(t=e.privateKeys[v])?t:null}),x=null!=(b=null==w?void 0:w.privateKey)?b:null,A=null!=(y=null==w?void 0:w.createdAt)?y:null,_=(0,a.useMemo)(()=>(u.http||(u.http=new t.HttpTransport),u.ws||(u.ws=new i.WebSocketTransport),f.info||(f.info=new r.InfoClient({transport:u.http})),f.subscription||(f.subscription=new n.SubscriptionClient({transport:u.ws})),v!==f.lastWalletAddress&&(f.wallet=m.data?new o.ExchangeClient({wallet:m.data,transport:u.http}):void 0,f.lastWalletAddress=null!=v?v:null),{info:f.info,subscription:f.subscription,wallet:f.wallet}),[m.data,v]),{data:E}=(0,s.useQuery)({queryKey:["hyperliquid-apiWalletClient",v,x,A],queryFn:async()=>{var e;if(!(v&&x&&u.http))return null;if(!A||Date.now()-A>l.HYPERLIQUID_PRIVATE_KEY_EXPIRY_MS)return d.useHyperliquidInfoStore.getState().setPrivateKey(v,null),null;let t=await (null==(e=f.info)?void 0:e.extraAgents({user:v})),i=(0,p.privateKeyToAccount)(x).address;return(null==t?void 0:t.some(e=>e.address.toLowerCase()===i.toLowerCase()))?new o.ExchangeClient({wallet:(0,p.privateKeyToAccount)(x),transport:u.http}):null},enabled:!!v&&!!f.info&&!!w});return{..._,apiWallet:null!=E?E:void 0}}}]);
!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="37cf6e25-d1f3-5ae9-8434-b8f3a676ca05")}catch(e){}}();
//# debugId=37cf6e25-d1f3-5ae9-8434-b8f3a676ca05
