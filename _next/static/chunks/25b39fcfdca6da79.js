(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,24287,235483,448146,373912,969641,564827,598706,878330,22187,949770,381256,121885,910509,719371,893128,378856,54549,536175,49445,189121,238888,775774,726558,47360,212452,421914,171816,666446,363957,510249,267516,661685,170303,41501,552948,901101,286077,742342,668264,272018,532578,732694,984358,676001,753726,769598,191436,382488,135194,918934,32237,40744,581475,204053,297516,788349,331179,182569,291049,22277,886360,405939,195977,281839,282535,416618,943133,588995,715134,e=>{"use strict";let t,r,s,n;function i(e){var r,s,n;return{lang:null!=(r=null==e?void 0:e.lang)?r:null==t?void 0:t.lang,message:null==e?void 0:e.message,abortEarly:null!=(s=null==e?void 0:e.abortEarly)?s:null==t?void 0:t.abortEarly,abortPipeEarly:null!=(n=null==e?void 0:e.abortPipeEarly)?n:null==t?void 0:t.abortPipeEarly}}function a(e){var t,r,s;let n=typeof e;return"string"===n?'"'.concat(e,'"'):"number"===n||"bigint"===n||"boolean"===n?"".concat(e):"object"===n||"function"===n?null!=(s=e&&(null==(r=Object.getPrototypeOf(e))||null==(t=r.constructor)?void 0:t.name))?s:"null":n}function o(e,t,i,o,u){var l,d,p,c,f,y,m,h,g,v,q,T,k;let b=u&&"input"in u?u.input:i.value,A=null!=(d=null!=(l=null==u?void 0:u.expected)?l:e.expects)?d:null,x=null!=(p=null==u?void 0:u.received)?p:a(b),S={kind:e.kind,type:e.type,input:b,expected:A,received:x,message:"Invalid ".concat(t,": ").concat(A?"Expected ".concat(A," but r"):"R","eceived ").concat(x),requirement:e.requirement,path:null==u?void 0:u.path,issues:null==u?void 0:u.issues,lang:o.lang,abortEarly:o.abortEarly,abortPipeEarly:o.abortPipeEarly},R="schema"===e.kind,w=null!=(h=null!=(m=null!=(y=null!=(f=null!=(c=null==u?void 0:u.message)?c:e.message)?f:(g=e.reference,v=S.lang,null==n||null==(q=n.get(g))?void 0:q.get(v)))?y:R?(T=S.lang,null==s?void 0:s.get(T)):null)?m:o.message)?h:(k=S.lang,null==r?void 0:r.get(k));void 0!==w&&(S.message="function"==typeof w?w(S):w),R&&(i.typed=!1),i.issues?i.issues.push(S):i.issues=[S]}function u(e){return{version:1,vendor:"valibot",validate:t=>e["~run"]({value:t},i())}}function l(e,t){return Object.hasOwn(e,t)&&"__proto__"!==t&&"prototype"!==t&&"constructor"!==t}function d(e,t){var r;let s=[...new Set(e)];return s.length>1?"(".concat(s.join(" ".concat(t," ")),")"):null!=(r=s[0])?r:"never"}e.s(["ActiveAssetDataResponse",()=>ep,"activeAssetData",()=>ec],24287),e.s(["array",()=>P,"boolean",()=>E,"check",()=>m,"description",()=>h,"function",()=>O,"integer",()=>g,"ip",()=>v,"ipv4",()=>q,"is",()=>I,"isoDate",()=>T,"length",()=>k,"literal",()=>M,"looseObject",()=>j,"minLength",()=>b,"minValue",()=>A,"null",()=>F,"nullable",()=>L,"nullish",()=>B,"number",()=>z,"object",()=>V,"omit",()=>K,"optional",()=>N,"parse",()=>Y,"parseJson",()=>x,"picklist",()=>W,"pipe",()=>Z,"record",()=>_,"regex",()=>S,"safeInteger",()=>R,"string",()=>H,"stringifyJson",()=>w,"transform",()=>D,"tuple",()=>$,"union",()=>J,"unknown",()=>G,"variant",()=>Q],235483);var p=class extends Error{constructor(e){super(e[0].message),this.name="ValiError",this.issues=e}};RegExp("^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$","u");let c=/^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u,f=/^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu,y=/^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;function m(e,t){return{kind:"validation",type:"check",reference:m,async:!1,expects:null,requirement:e,message:t,"~run"(e,t){return e.typed&&!this.requirement(e.value)&&o(this,"input",e,t),e}}}function h(e){return{kind:"metadata",type:"description",reference:h,description:e}}function g(e){return{kind:"validation",type:"integer",reference:g,async:!1,expects:null,requirement:Number.isInteger,message:e,"~run"(e,t){return e.typed&&!this.requirement(e.value)&&o(this,"integer",e,t),e}}}function v(e){return{kind:"validation",type:"ip",reference:v,async:!1,expects:null,requirement:f,message:e,"~run"(e,t){return e.typed&&!this.requirement.test(e.value)&&o(this,"IP",e,t),e}}}function q(e){return{kind:"validation",type:"ipv4",reference:q,async:!1,expects:null,requirement:c,message:e,"~run"(e,t){return e.typed&&!this.requirement.test(e.value)&&o(this,"IPv4",e,t),e}}}function T(e){return{kind:"validation",type:"iso_date",reference:T,async:!1,expects:null,requirement:y,message:e,"~run"(e,t){return e.typed&&!this.requirement.test(e.value)&&o(this,"date",e,t),e}}}function k(e,t){return{kind:"validation",type:"length",reference:k,async:!1,expects:"".concat(e),requirement:e,message:t,"~run"(e,t){return e.typed&&e.value.length!==this.requirement&&o(this,"length",e,t,{received:"".concat(e.value.length)}),e}}}function b(e,t){return{kind:"validation",type:"min_length",reference:b,async:!1,expects:">=".concat(e),requirement:e,message:t,"~run"(e,t){return e.typed&&e.value.length<this.requirement&&o(this,"length",e,t,{received:"".concat(e.value.length)}),e}}}function A(e,t){return{kind:"validation",type:"min_value",reference:A,async:!1,expects:">=".concat(e instanceof Date?e.toJSON():a(e)),requirement:e,message:t,"~run"(e,t){return e.typed&&!(e.value>=this.requirement)&&o(this,"value",e,t,{received:e.value instanceof Date?e.value.toJSON():a(e.value)}),e}}}function x(e,t){return{kind:"transformation",type:"parse_json",reference:x,config:e,message:t,async:!1,"~run"(e,t){try{var r;e.value=JSON.parse(e.value,null==(r=this.config)?void 0:r.reviver)}catch(r){if(r instanceof Error)o(this,"JSON",e,t,{received:'"'.concat(r.message,'"')}),e.typed=!1;else throw r}return e}}}function S(e,t){return{kind:"validation",type:"regex",reference:S,async:!1,expects:"".concat(e),requirement:e,message:t,"~run"(e,t){return e.typed&&!this.requirement.test(e.value)&&o(this,"format",e,t),e}}}function R(e){return{kind:"validation",type:"safe_integer",reference:R,async:!1,expects:null,requirement:Number.isSafeInteger,message:e,"~run"(e,t){return e.typed&&!this.requirement(e.value)&&o(this,"safe integer",e,t),e}}}function w(e,t){return{kind:"transformation",type:"stringify_json",reference:w,message:t,config:e,async:!1,"~run"(e,t){try{var r,s;let n=JSON.stringify(e.value,null==(r=this.config)?void 0:r.replacer,null==(s=this.config)?void 0:s.space);void 0===n&&(o(this,"JSON",e,t),e.typed=!1),e.value=n}catch(r){if(r instanceof Error)o(this,"JSON",e,t,{received:'"'.concat(r.message,'"')}),e.typed=!1;else throw r}return e}}}function D(e){return{kind:"transformation",type:"transform",reference:D,async:!1,operation:e,"~run"(e){return e.value=this.operation(e.value),e}}}function C(e,t,r){return"function"==typeof e.fallback?e.fallback(t,r):e.fallback}function U(e,t,r){return"function"==typeof e.default?e.default(t,r):e.default}function I(e,t){return!e["~run"]({value:t},{abortEarly:!0}).issues}function P(e,t){return{kind:"schema",type:"array",reference:P,expects:"Array",async:!1,item:e,message:t,get"~standard"(){return u(this)},"~run"(e,t){let r=e.value;if(Array.isArray(r)){e.typed=!0,e.value=[];for(let n=0;n<r.length;n++){let i=r[n],a=this.item["~run"]({value:i},t);if(a.issues){let o={type:"array",origin:"value",input:r,key:n,value:i};for(let t of a.issues){var s;t.path?t.path.unshift(o):t.path=[o],null==(s=e.issues)||s.push(t)}if(e.issues||(e.issues=a.issues),t.abortEarly){e.typed=!1;break}}a.typed||(e.typed=!1),e.value.push(a.value)}}else o(this,"type",e,t);return e}}}function E(e){return{kind:"schema",type:"boolean",reference:E,expects:"boolean",async:!1,message:e,get"~standard"(){return u(this)},"~run"(e,t){return"boolean"==typeof e.value?e.typed=!0:o(this,"type",e,t),e}}}function O(e){return{kind:"schema",type:"function",reference:O,expects:"Function",async:!1,message:e,get"~standard"(){return u(this)},"~run"(e,t){return"function"==typeof e.value?e.typed=!0:o(this,"type",e,t),e}}}function M(e,t){return{kind:"schema",type:"literal",reference:M,expects:a(e),async:!1,literal:e,message:t,get"~standard"(){return u(this)},"~run"(e,t){return e.value===this.literal?e.typed=!0:o(this,"type",e,t),e}}}function j(e,t){return{kind:"schema",type:"loose_object",reference:j,expects:"Object",async:!1,entries:e,message:t,get"~standard"(){return u(this)},"~run"(e,t){let r=e.value;if(r&&"object"==typeof r){for(let n in e.typed=!0,e.value={},this.entries){let i=this.entries[n];if(n in r||("exact_optional"===i.type||"optional"===i.type||"nullish"===i.type)&&void 0!==i.default){let a=n in r?r[n]:U(i),o=i["~run"]({value:a},t);if(o.issues){let i={type:"object",origin:"value",input:r,key:n,value:a};for(let t of o.issues){var s;t.path?t.path.unshift(i):t.path=[i],null==(s=e.issues)||s.push(t)}if(e.issues||(e.issues=o.issues),t.abortEarly){e.typed=!1;break}}o.typed||(e.typed=!1),e.value[n]=o.value}else if(void 0!==i.fallback)e.value[n]=C(i);else if("exact_optional"!==i.type&&"optional"!==i.type&&"nullish"!==i.type&&(o(this,"key",e,t,{input:void 0,expected:'"'.concat(n,'"'),path:[{type:"object",origin:"key",input:r,key:n,value:r[n]}]}),t.abortEarly))break}if(!e.issues||!t.abortEarly)for(let t in r)!l(r,t)||t in this.entries||(e.value[t]=r[t])}else o(this,"type",e,t);return e}}}function F(e){return{kind:"schema",type:"null",reference:F,expects:"null",async:!1,message:e,get"~standard"(){return u(this)},"~run"(e,t){return null===e.value?e.typed=!0:o(this,"type",e,t),e}}}function L(e,t){return{kind:"schema",type:"nullable",reference:L,expects:"(".concat(e.expects," | null)"),async:!1,wrapped:e,default:t,get"~standard"(){return u(this)},"~run"(e,t){return null===e.value&&(void 0!==this.default&&(e.value=U(this,e,t)),null===e.value)?(e.typed=!0,e):this.wrapped["~run"](e,t)}}}function B(e,t){return{kind:"schema",type:"nullish",reference:B,expects:"(".concat(e.expects," | null | undefined)"),async:!1,wrapped:e,default:t,get"~standard"(){return u(this)},"~run"(e,t){return(null===e.value||void 0===e.value)&&(void 0!==this.default&&(e.value=U(this,e,t)),null===e.value||void 0===e.value)?(e.typed=!0,e):this.wrapped["~run"](e,t)}}}function z(e){return{kind:"schema",type:"number",reference:z,expects:"number",async:!1,message:e,get"~standard"(){return u(this)},"~run"(e,t){return"number"!=typeof e.value||isNaN(e.value)?o(this,"type",e,t):e.typed=!0,e}}}function V(e,t){return{kind:"schema",type:"object",reference:V,expects:"Object",async:!1,entries:e,message:t,get"~standard"(){return u(this)},"~run"(e,t){let r=e.value;if(r&&"object"==typeof r)for(let n in e.typed=!0,e.value={},this.entries){let i=this.entries[n];if(n in r||("exact_optional"===i.type||"optional"===i.type||"nullish"===i.type)&&void 0!==i.default){let a=n in r?r[n]:U(i),o=i["~run"]({value:a},t);if(o.issues){let i={type:"object",origin:"value",input:r,key:n,value:a};for(let t of o.issues){var s;t.path?t.path.unshift(i):t.path=[i],null==(s=e.issues)||s.push(t)}if(e.issues||(e.issues=o.issues),t.abortEarly){e.typed=!1;break}}o.typed||(e.typed=!1),e.value[n]=o.value}else if(void 0!==i.fallback)e.value[n]=C(i);else if("exact_optional"!==i.type&&"optional"!==i.type&&"nullish"!==i.type&&(o(this,"key",e,t,{input:void 0,expected:'"'.concat(n,'"'),path:[{type:"object",origin:"key",input:r,key:n,value:r[n]}]}),t.abortEarly))break}else o(this,"type",e,t);return e}}}function N(e,t){return{kind:"schema",type:"optional",reference:N,expects:"(".concat(e.expects," | undefined)"),async:!1,wrapped:e,default:t,get"~standard"(){return u(this)},"~run"(e,t){return void 0===e.value&&(void 0!==this.default&&(e.value=U(this,e,t)),void 0===e.value)?(e.typed=!0,e):this.wrapped["~run"](e,t)}}}function W(e,t){return{kind:"schema",type:"picklist",reference:W,expects:d(e.map(a),"|"),async:!1,options:e,message:t,get"~standard"(){return u(this)},"~run"(e,t){return this.options.includes(e.value)?e.typed=!0:o(this,"type",e,t),e}}}function _(e,t,r){return{kind:"schema",type:"record",reference:_,expects:"Object",async:!1,key:e,value:t,message:r,get"~standard"(){return u(this)},"~run"(e,t){let r=e.value;if(r&&"object"==typeof r){for(let i in e.typed=!0,e.value={},r)if(l(r,i)){var s,n;let a=r[i],o=this.key["~run"]({value:i},t);if(o.issues){let n={type:"object",origin:"key",input:r,key:i,value:a};for(let t of o.issues)t.path=[n],null==(s=e.issues)||s.push(t);if(e.issues||(e.issues=o.issues),t.abortEarly){e.typed=!1;break}}let u=this.value["~run"]({value:a},t);if(u.issues){let s={type:"object",origin:"value",input:r,key:i,value:a};for(let t of u.issues)t.path?t.path.unshift(s):t.path=[s],null==(n=e.issues)||n.push(t);if(e.issues||(e.issues=u.issues),t.abortEarly){e.typed=!1;break}}o.typed&&u.typed||(e.typed=!1),o.typed&&(e.value[o.value]=u.value)}}else o(this,"type",e,t);return e}}}function H(e){return{kind:"schema",type:"string",reference:H,expects:"string",async:!1,message:e,get"~standard"(){return u(this)},"~run"(e,t){return"string"==typeof e.value?e.typed=!0:o(this,"type",e,t),e}}}function $(e,t){return{kind:"schema",type:"tuple",reference:$,expects:"Array",async:!1,items:e,message:t,get"~standard"(){return u(this)},"~run"(e,t){let r=e.value;if(Array.isArray(r)){e.typed=!0,e.value=[];for(let n=0;n<this.items.length;n++){let i=r[n],a=this.items[n]["~run"]({value:i},t);if(a.issues){let o={type:"array",origin:"value",input:r,key:n,value:i};for(let t of a.issues){var s;t.path?t.path.unshift(o):t.path=[o],null==(s=e.issues)||s.push(t)}if(e.issues||(e.issues=a.issues),t.abortEarly){e.typed=!1;break}}a.typed||(e.typed=!1),e.value.push(a.value)}}else o(this,"type",e,t);return e}}}function X(e){let t;if(e)for(let r of e)t?t.push(...r.issues):t=r.issues;return t}function J(e,t){return{kind:"schema",type:"union",reference:J,expects:d(e.map(e=>e.expects),"|"),async:!1,options:e,message:t,get"~standard"(){return u(this)},"~run"(e,t){let r,s,n;for(let i of this.options){let a=i["~run"]({value:e.value},t);if(a.typed)if(a.issues)s?s.push(a):s=[a];else{r=a;break}else n?n.push(a):n=[a]}if(r)return r;if(s){if(1===s.length)return s[0];o(this,"type",e,t,{issues:X(s)}),e.typed=!0}else{if((null==n?void 0:n.length)===1)return n[0];o(this,"type",e,t,{issues:X(n)})}return e}}}function G(){return{kind:"schema",type:"unknown",reference:G,expects:"unknown",async:!1,get"~standard"(){return u(this)},"~run":e=>(e.typed=!0,e)}}function Q(e,t,r){return{kind:"schema",type:"variant",reference:Q,expects:"Object",async:!1,key:e,options:t,message:r,get"~standard"(){return u(this)},"~run"(e,t){let r=e.value;if(r&&"object"==typeof r){let s,n=0,i=this.key,a=[],u=(e,o)=>{for(let l of e.options){if("variant"===l.type)u(l,new Set(o).add(l.key));else{let e=!0,u=0;for(let t of o){let s=l.entries[t];if(t in r?s["~run"]({typed:!1,value:r[t]},{abortEarly:!0}).issues:"exact_optional"!==s.type&&"optional"!==s.type&&"nullish"!==s.type){e=!1,i!==t&&(n<u||n===u&&t in r&&!(i in r))&&(n=u,i=t,a=[]),i===t&&a.push(l.entries[t].expects);break}u++}if(e){let e=l["~run"]({value:r},t);s&&(s.typed||!e.typed)||(s=e)}}if(s&&!s.issues)break}};if(u(this,new Set([this.key])),s)return s;o(this,"type",e,t,{input:r[i],expected:d(a,"|"),path:[{type:"object",origin:"value",input:r,key:i,value:r[i]}]})}else o(this,"type",e,t);return e}}}function K(e,t){let r={...e.entries};for(let e of t)delete r[e];return{...e,entries:r,get"~standard"(){return u(this)}}}function Y(e,t,r){let s=e["~run"]({value:t},i(r));if(s.issues)throw new p(s.issues);return s.value}function Z(){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];return{...t[0],pipe:t,get"~standard"(){return u(this)},"~run"(e,r){for(let s of t)if("metadata"!==s.kind){if(e.issues&&("schema"===s.kind||"transformation"===s.kind)){e.typed=!1;break}e.issues&&(r.abortEarly||r.abortPipeEarly)||(e=s["~run"](e,r))}return e}}}e.s(["Address",()=>ei,"Decimal",()=>et,"Hex",()=>en,"ISO8601WithoutTimezone",()=>eu,"Integer",()=>er,"Percent",()=>eo,"TokenId",()=>ea,"UnsignedDecimal",()=>ee,"UnsignedInteger",()=>es],448146);let ee=Z(J([H(),z()]),D(String),H(),D(e=>el(e)),S(/^[0-9]+(\.[0-9]+)?$/)),et=Z(J([H(),z()]),D(String),H(),D(e=>el(e)),S(/^-?[0-9]+(\.[0-9]+)?$/)),er=Z(J([H(),z()]),D(Number),z(),g(),R()),es=Z(J([H(),z()]),D(Number),z(),g(),R(),A(0)),en=Z(H(),S(/^0[xX][0-9a-fA-F]+$/),D(e=>e.toLowerCase())),ei=Z(en,k(42)),ea=Z(H(),S(/^[^:]+:0x[0-9a-fA-F]+$/),D(e=>e)),eo=Z(H(),S(/^[0-9]+(\.[0-9]+)?%$/),D(e=>e)),eu=Z(H(),S(/^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?$/));function el(e){return e.trim().replace(/^(-?)0+(?=\d)/,"$1").replace(/\.0*$|(\.\d+?)0+$/,"$1").replace(/^(-?)\./,"$10.").replace(/^-?$/,"0").replace(/^-0$/,"0")}let ed=Z(V({type:Z(M("activeAssetData"),h("Type of request.")),coin:Z(H(),h("Asset symbol (e.g., BTC).")),user:Z(ei,h("User address."))}),h("Request user active asset data.")),ep=Z(V({user:Z(ei,h("User address.")),coin:Z(H(),h("Asset symbol (e.g., BTC).")),leverage:Z(Q("type",[V({type:Z(M("isolated"),h("Leverage type.")),value:Z(es,A(1),h("Leverage value used.")),rawUsd:Z(ee,h("Amount of USD used (1 = $1)."))}),V({type:Z(M("cross"),h("Leverage type.")),value:Z(es,A(1),h("Leverage value used."))})]),h("Leverage configuration.")),maxTradeSzs:Z($([ee,ee]),h("Maximum trade size range [min, max].")),availableToTrade:Z($([ee,ee]),h("Available to trade range [min, max].")),markPx:Z(ee,h("Mark price."))}),h("User active asset data."));function ec(e,t,r){let s=Y(ed,{type:"activeAssetData",...t});return e.transport.request("info",s,r)}e.s(["alignedQuoteTokenInfo",()=>ey],373912);let ef=Z(V({type:Z(M("alignedQuoteTokenInfo"),h("Type of request.")),token:Z(es,h("Token index."))}),h("Request supply, rate, and pending payment information for an aligned quote token."));function ey(e,t,r){let s=Y(ef,{type:"alignedQuoteTokenInfo",...t});return e.transport.request("info",s,r)}e.s(["AllMidsResponse",()=>eh,"allMids",()=>eg],969641);let em=Z(V({type:Z(M("allMids"),h("Type of request.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request mid coin prices.")),eh=Z(_(H(),ee),h("Mapping of coin symbols to mid prices."));function eg(e,t,r){let s=t instanceof AbortSignal?{}:t,n=t instanceof AbortSignal?t:r,i=Y(em,{type:"allMids",...s});return e.transport.request("info",i,n)}e.s(["allPerpMetas",()=>eS],878330),e.s(["MetaResponse",()=>eb,"meta",()=>eA],598706),e.s(["MarginTableResponse",()=>eq,"marginTable",()=>eT],564827);let ev=Z(V({type:Z(M("marginTable"),h("Type of request.")),id:Z(es,h("Margin requirements table."))}),h("Request margin table data.")),eq=Z(V({description:Z(H(),h("Description of the margin table.")),marginTiers:Z(P(Z(V({lowerBound:Z(ee,h("Lower position size boundary for this tier.")),maxLeverage:Z(es,A(1),h("Maximum allowed leverage for this tier."))}),h("Individual tier in a margin requirements table."))),h("Array of margin tiers defining leverage limits."))}),h("Margin requirements table with multiple tiers."));function eT(e,t,r){let s=Y(ev,{type:"marginTable",...t});return e.transport.request("info",s,r)}let ek=Z(V({type:Z(M("meta"),h("Type of request.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request trading metadata.")),eb=Z(V({universe:Z(P(Z(V({szDecimals:Z(es,h("Minimum decimal places for order sizes.")),name:Z(H(),h("Name of the universe.")),maxLeverage:Z(es,A(1),h("Maximum allowed leverage.")),marginTableId:Z(es,h("Unique identifier for the margin requirements table.")),onlyIsolated:Z(N(M(!0)),h("Indicates if only isolated margin trading is allowed.")),isDelisted:Z(N(M(!0)),h("Indicates if the universe is delisted.")),marginMode:Z(N(W(["strictIsolated","noCross"])),h("Trading margin mode constraint.")),growthMode:Z(N(M("enabled")),h("Indicates if growth mode is enabled.")),lastGrowthModeChangeTime:Z(N(eu),h("Timestamp of the last growth mode change."))}),h("Trading universe parameters for perpetual asset."))),h("Trading universes available for perpetual trading.")),marginTables:Z(P(Z($([es,eq]),h("Tuple of margin table ID and its details."))),h("Margin requirement tables for different leverage tiers.")),collateralToken:Z(es,h("Collateral token index."))}),h("Metadata for perpetual assets."));function eA(e,t,r){let s=t instanceof AbortSignal?{}:t,n=t instanceof AbortSignal?t:r,i=Y(ek,{type:"meta",...s});return e.transport.request("info",i,n)}let ex=Z(V({type:Z(M("allPerpMetas"),h("Type of request."))}),h("Request trading metadata for all DEXes."));function eS(e,t){let r=Y(ex,{type:"allPerpMetas"});return e.transport.request("info",r,t)}e.s(["blockDetails",()=>ew],22187);let eR=Z(V({type:Z(M("blockDetails"),h("Type of request.")),height:Z(es,h("Block height."))}),h("Request block details by block height."));function ew(e,t,r){let s=Y(eR,{type:"blockDetails",...t});return e.transport.request("explorer",s,r)}e.s(["candleSnapshot",()=>eC],949770);let eD=Z(V({type:Z(M("candleSnapshot"),h("Type of request.")),req:Z(V({coin:Z(H(),h("Asset symbol (e.g., BTC).")),interval:Z(W(["1m","3m","5m","15m","30m","1h","2h","4h","8h","12h","1d","3d","1w","1M"]),h("Time interval.")),startTime:Z(es,h("Start time (in ms since epoch).")),endTime:Z(B(es),h("End time (in ms since epoch)."))}),h("Request parameters."))}),h("Request candlestick snapshots."));function eC(e,t,r){let s=Y(eD,{type:"candleSnapshot",req:t});return e.transport.request("info",s,r)}e.s(["ClearinghouseStateResponse",()=>eI,"clearinghouseState",()=>eP],381256);let eU=Z(V({type:Z(M("clearinghouseState"),h("Type of request.")),user:Z(ei,h("User address.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request clearinghouse state.")),eI=Z(V({marginSummary:Z(V({accountValue:Z(ee,h("Total account value.")),totalNtlPos:Z(ee,h("Total notional position value.")),totalRawUsd:Z(ee,h("Total raw USD value.")),totalMarginUsed:Z(ee,h("Total margin used."))}),h("Margin summary details.")),crossMarginSummary:Z(V({accountValue:Z(ee,h("Total account value.")),totalNtlPos:Z(ee,h("Total notional position value.")),totalRawUsd:Z(ee,h("Total raw USD value.")),totalMarginUsed:Z(ee,h("Total margin used."))}),h("Cross-margin summary details.")),crossMaintenanceMarginUsed:Z(ee,h("Maintenance margin used for cross-margin positions.")),withdrawable:Z(ee,h("Amount available for withdrawal.")),assetPositions:Z(P(Z(V({type:Z(M("oneWay"),h("Position type.")),position:Z(V({coin:Z(H(),h("Asset symbol.")),szi:Z(et,h("Signed position size.")),leverage:Z(Q("type",[V({type:Z(M("isolated"),h("Leverage type.")),value:Z(es,A(1),h("Leverage value used.")),rawUsd:Z(ee,h("Amount of USD used (1 = $1)."))}),V({type:Z(M("cross"),h("Leverage type.")),value:Z(es,A(1),h("Leverage value used."))})]),h("Leverage details.")),entryPx:Z(ee,h("Average entry price.")),positionValue:Z(ee,h("Position value.")),unrealizedPnl:Z(et,h("Unrealized profit and loss.")),returnOnEquity:Z(et,h("Return on equity.")),liquidationPx:Z(L(ee),h("Liquidation price.")),marginUsed:Z(ee,h("Margin used.")),maxLeverage:Z(es,A(1),h("Maximum allowed leverage.")),cumFunding:Z(V({allTime:Z(et,h("Total funding paid or received since account opening.")),sinceOpen:Z(et,h("Funding accumulated since the position was opened.")),sinceChange:Z(et,h("Funding accumulated since the last change in position size."))}),h("Cumulative funding details."))}),h("Position details."))}),h("Position for a specific asset."))),h("Array of asset positions.")),time:Z(es,h("Timestamp when data was retrieved (in ms since epoch)."))}),h("Account summary for perpetual trading."));function eP(e,t,r){let s=Y(eU,{type:"clearinghouseState",...t});return e.transport.request("info",s,r)}e.s(["delegations",()=>eO],121885);let eE=Z(V({type:Z(M("delegations"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user staking delegations."));function eO(e,t,r){let s=Y(eE,{type:"delegations",...t});return e.transport.request("info",s,r)}e.s(["delegatorHistory",()=>ej],910509);let eM=Z(V({type:Z(M("delegatorHistory"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user staking history."));function ej(e,t,r){let s=Y(eM,{type:"delegatorHistory",...t});return e.transport.request("info",s,r)}e.s(["delegatorRewards",()=>eL],719371);let eF=Z(V({type:Z(M("delegatorRewards"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user staking rewards."));function eL(e,t,r){let s=Y(eF,{type:"delegatorRewards",...t});return e.transport.request("info",s,r)}e.s(["delegatorSummary",()=>ez],893128);let eB=Z(V({type:Z(M("delegatorSummary"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user's staking summary."));function ez(e,t,r){let s=Y(eB,{type:"delegatorSummary",...t});return e.transport.request("info",s,r)}e.s(["exchangeStatus",()=>eN],378856);let eV=Z(V({type:Z(M("exchangeStatus"),h("Type of request."))}),h("Request exchange system status information."));function eN(e,t){let r=Y(eV,{type:"exchangeStatus"});return e.transport.request("info",r,t)}e.s(["extraAgents",()=>e_],54549);let eW=Z(V({type:Z(M("extraAgents"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user extra agents."));function e_(e,t,r){let s=Y(eW,{type:"extraAgents",...t});return e.transport.request("info",s,r)}e.s(["FrontendOpenOrdersResponse",()=>e$,"frontendOpenOrders",()=>eX],536175);let eH=Z(V({type:Z(M("frontendOpenOrders"),h("Type of request.")),user:Z(ei,h("User address.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request frontend open orders.")),e$=Z(P(Z(V({coin:Z(H(),h("Asset symbol.")),side:Z(W(["B","A"]),h('Order side ("B" = Bid/Buy, "A" = Ask/Sell).')),limitPx:Z(ee,h("Limit price.")),sz:Z(ee,h("Size.")),oid:Z(es,h("Order ID.")),timestamp:Z(es,h("Timestamp when the order was placed (in ms since epoch).")),origSz:Z(ee,h("Original size at order placement.")),triggerCondition:Z(H(),h("Condition for triggering the order.")),isTrigger:Z(E(),h("Indicates if the order is a trigger order.")),triggerPx:Z(ee,h("Trigger price.")),children:Z(P(G()),h("Child orders associated with this order.")),isPositionTpsl:Z(E(),h("Indicates if the order is a position TP/SL order.")),reduceOnly:Z(E(),h("Indicates whether the order is reduce-only.")),orderType:Z(W(["Market","Limit","Stop Market","Stop Limit","Take Profit Market","Take Profit Limit"]),h('Order type for market execution.\n- `"Market"`: Executes immediately at the market price.\n- `"Limit"`: Executes at the specified limit price or better.\n- `"Stop Market"`: Activates as a market order when a stop price is reached.\n- `"Stop Limit"`: Activates as a limit order when a stop price is reached.\n- `"Take Profit Market"`: Executes as a market order when a take profit price is reached.\n- `"Take Profit Limit"`: Executes as a limit order when a take profit price is reached. ')),tif:Z(L(W(["Gtc","Ioc","Alo","FrontendMarket","LiquidationMarket"])),h('Time-in-force.\n- `"Gtc"`: Remains active until filled or canceled.\n- `"Ioc"`: Fills immediately or cancels any unfilled portion.\n- `"Alo"`: Adds liquidity only.\n- `"FrontendMarket"`: Similar to Ioc, used in Hyperliquid UI.\n- `"LiquidationMarket"`: Similar to Ioc, used in Hyperliquid UI.')),cloid:Z(L(Z(en,k(34))),h("Client Order ID."))}),h("Open order with additional display information."))),h("Array of open orders with additional display information."));function eX(e,t,r){let s=Y(eH,{type:"frontendOpenOrders",...t});return e.transport.request("info",s,r)}e.s(["fundingHistory",()=>eG],49445);let eJ=Z(V({type:Z(M("fundingHistory"),h("Type of request.")),coin:Z(H(),h("Asset symbol (e.g., BTC).")),startTime:Z(es,h("Start time (in ms since epoch).")),endTime:Z(B(es),h("End time (in ms since epoch)."))}),h("Request funding history."));function eG(e,t,r){let s=Y(eJ,{type:"fundingHistory",...t});return e.transport.request("info",s,r)}e.s(["gossipRootIps",()=>eK],189121);let eQ=Z(V({type:Z(M("gossipRootIps"),h("Type of request."))}),h("Request gossip root IPs."));function eK(e,t){let r=Y(eQ,{type:"gossipRootIps"});return e.transport.request("info",r,t)}e.s(["HistoricalOrdersResponse",()=>eZ,"historicalOrders",()=>e1],238888);let eY=Z(V({type:Z(M("historicalOrders"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user historical orders.")),eZ=Z(P(Z(V({order:Z(V({coin:Z(H(),h("Asset symbol.")),side:Z(W(["B","A"]),h('Order side ("B" = Bid/Buy, "A" = Ask/Sell).')),limitPx:Z(ee,h("Limit price.")),sz:Z(ee,h("Size.")),oid:Z(es,h("Order ID.")),timestamp:Z(es,h("Timestamp when the order was placed (in ms since epoch).")),origSz:Z(ee,h("Original size at order placement.")),triggerCondition:Z(H(),h("Condition for triggering the order.")),isTrigger:Z(E(),h("Indicates if the order is a trigger order.")),triggerPx:Z(ee,h("Trigger price.")),children:Z(P(G()),h("Child orders associated with this order.")),isPositionTpsl:Z(E(),h("Indicates if the order is a position TP/SL order.")),reduceOnly:Z(E(),h("Indicates whether the order is reduce-only.")),orderType:Z(W(["Market","Limit","Stop Market","Stop Limit","Take Profit Market","Take Profit Limit"]),h('Order type for market execution.\n- `"Market"`: Executes immediately at the market price.\n- `"Limit"`: Executes at the specified limit price or better.\n- `"Stop Market"`: Activates as a market order when a stop price is reached.\n- `"Stop Limit"`: Activates as a limit order when a stop price is reached.\n- `"Take Profit Market"`: Executes as a market order when a take profit price is reached.\n- `"Take Profit Limit"`: Executes as a limit order when a take profit price is reached. ')),tif:Z(L(W(["Gtc","Ioc","Alo","FrontendMarket","LiquidationMarket"])),h('Time-in-force.\n- `"Gtc"`: Remains active until filled or canceled.\n- `"Ioc"`: Fills immediately or cancels any unfilled portion.\n- `"Alo"`: Adds liquidity only.\n- `"FrontendMarket"`: Similar to Ioc, used in Hyperliquid UI.\n- `"LiquidationMarket"`: Similar to Ioc, used in Hyperliquid UI.')),cloid:Z(L(Z(en,k(34))),h("Client Order ID."))}),h("Open order with additional display information.")),status:Z(W(["open","filled","canceled","triggered","rejected","marginCanceled","vaultWithdrawalCanceled","openInterestCapCanceled","selfTradeCanceled","reduceOnlyCanceled","siblingFilledCanceled","delistedCanceled","liquidatedCanceled","scheduledCancel","tickRejected","minTradeNtlRejected","perpMarginRejected","reduceOnlyRejected","badAloPxRejected","iocCancelRejected","badTriggerPxRejected","marketOrderNoLiquidityRejected","positionIncreaseAtOpenInterestCapRejected","positionFlipAtOpenInterestCapRejected","tooAggressiveAtOpenInterestCapRejected","openInterestIncreaseRejected","insufficientSpotBalanceRejected","oracleRejected","perpMaxPositionRejected"]),h('Order processing status.\n- `"open"`: Order active and waiting to be filled.\n- `"filled"`: Order fully executed.\n- `"canceled"`: Order canceled by the user.\n- `"triggered"`: Order triggered and awaiting execution.\n- `"rejected"`: Order rejected by the system.\n- `"marginCanceled"`: Order canceled due to insufficient margin.\n- `"vaultWithdrawalCanceled"`: Canceled due to a user withdrawal from vault.\n- `"openInterestCapCanceled"`: Canceled due to order being too aggressive when open interest was at cap.\n- `"selfTradeCanceled"`: Canceled due to self-trade prevention.\n- `"reduceOnlyCanceled"`: Canceled reduced-only order that does not reduce position.\n- `"siblingFilledCanceled"`: Canceled due to sibling ordering being filled.\n- `"delistedCanceled"`: Canceled due to asset delisting.\n- `"liquidatedCanceled"`: Canceled due to liquidation.\n- `"scheduledCancel"`: Canceled due to exceeding scheduled cancel deadline (dead man\'s switch).\n- `"tickRejected"`: Rejected due to invalid tick price.\n- `"minTradeNtlRejected"`: Rejected due to order notional below minimum.\n- `"perpMarginRejected"`: Rejected due to insufficient margin.\n- `"reduceOnlyRejected"`: Rejected due to reduce only.\n- `"badAloPxRejected"`: Rejected due to post-only immediate match.\n- `"iocCancelRejected"`: Rejected due to IOC not able to match.\n- `"badTriggerPxRejected"`: Rejected due to invalid TP/SL price.\n- `"marketOrderNoLiquidityRejected"`: Rejected due to lack of liquidity for market order.\n- `"positionIncreaseAtOpenInterestCapRejected"`: Rejected due to open interest cap.\n- `"positionFlipAtOpenInterestCapRejected"`: Rejected due to open interest cap.\n- `"tooAggressiveAtOpenInterestCapRejected"`: Rejected due to price too aggressive at open interest cap.\n- `"openInterestIncreaseRejected"`: Rejected due to open interest cap.\n- `"insufficientSpotBalanceRejected"`: Rejected due to insufficient spot balance.\n- `"oracleRejected"`: Rejected due to price too far from oracle.\n- `"perpMaxPositionRejected"`: Rejected due to exceeding margin tier limit at current leverage.')),statusTimestamp:Z(es,h("Timestamp when the status was last updated (in ms since epoch)."))}),h("Frontend order with current processing status."))),h("Array of frontend orders with current processing status."));function e1(e,t,r){let s=Y(eY,{type:"historicalOrders",...t});return e.transport.request("info",s,r)}e.s(["isVip",()=>e4],775774);let e0=Z(V({type:Z(M("isVip"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request to check if a user is a VIP."));function e4(e,t,r){let s=Y(e0,{type:"isVip",...t});return e.transport.request("info",s,r)}e.s(["l2Book",()=>e5],726558);let e2=Z(V({type:Z(M("l2Book"),h("Type of request.")),coin:Z(H(),h("Asset symbol (e.g., BTC).")),nSigFigs:Z(B(W([2,3,4,5])),h("Number of significant figures.")),mantissa:Z(B(W([2,5])),h("Mantissa for aggregation (if `nSigFigs` is 5)."))}),h("Request L2 order book."));function e5(e,t,r){let s=Y(e2,{type:"l2Book",...t});return e.transport.request("info",s,r)}e.s(["LeadingVaultsResponse",()=>e9,"leadingVaults",()=>e8],47360);let e3=Z(V({type:Z(M("leadingVaults"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request leading vaults for a user.")),e9=Z(P(Z(V({address:Z(ei,h("Vault address.")),name:Z(H(),h("Vault name."))}),h("Vault that a user is leading."))),h("Array of leading vaults for a user."));function e8(e,t,r){let s=Y(e3,{type:"leadingVaults",...t});return e.transport.request("info",s,r)}e.s(["legalCheck",()=>e7],212452);let e6=Z(V({type:Z(M("legalCheck"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request legal verification status of a user."));function e7(e,t,r){let s=Y(e6,{type:"legalCheck",...t});return e.transport.request("info",s,r)}e.s(["liquidatable",()=>tt],421914);let te=Z(V({type:Z(M("liquidatable"),h("Type of request."))}),h("Request liquidatable."));function tt(e,t){let r=Y(te,{type:"liquidatable"});return e.transport.request("info",r,t)}e.s(["maxBuilderFee",()=>ts],171816);let tr=Z(V({type:Z(M("maxBuilderFee"),h("Type of request.")),user:Z(ei,h("User address.")),builder:Z(ei,h("Builder address."))}),h("Request builder fee approval."));function ts(e,t,r){let s=Y(tr,{type:"maxBuilderFee",...t});return e.transport.request("info",s,r)}e.s(["maxMarketOrderNtls",()=>ti],666446);let tn=Z(V({type:Z(M("maxMarketOrderNtls"),h("Type of request."))}),h("Request maximum market order notionals."));function ti(e,t){let r=Y(tn,{type:"maxMarketOrderNtls"});return e.transport.request("info",r,t)}e.s(["metaAndAssetCtxs",()=>to],363957);let ta=Z(V({type:Z(M("metaAndAssetCtxs"),h("Type of request.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request metadata and asset contexts."));function to(e,t,r){let s=t instanceof AbortSignal?{}:t,n=t instanceof AbortSignal?t:r,i=Y(ta,{type:"metaAndAssetCtxs",...s});return e.transport.request("info",i,n)}e.s(["openOrders",()=>tl],510249);let tu=Z(V({type:Z(M("openOrders"),h("Type of request.")),user:Z(ei,h("User address.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request open orders."));function tl(e,t,r){let s=Y(tu,{type:"openOrders",...t});return e.transport.request("info",s,r)}e.s(["orderStatus",()=>tp],267516);let td=Z(V({type:Z(M("orderStatus"),h("Type of request.")),user:Z(ei,h("User address.")),oid:Z(J([es,Z(en,k(34))]),h("Order ID or Client Order ID."))}),h("Request order status."));function tp(e,t,r){let s=Y(td,{type:"orderStatus",...t});return e.transport.request("info",s,r)}e.s(["PerpDeployAuctionStatusResponse",()=>tf,"perpDeployAuctionStatus",()=>ty],661685);let tc=Z(V({type:Z(M("perpDeployAuctionStatus"),h("Type of request."))}),h("Request for the status of the perpetual deploy auction.")),tf=Z(V({currentGas:Z(L(ee),h("Current gas.")),durationSeconds:Z(es,h("Duration in seconds.")),endGas:Z(L(ee),h("Ending gas.")),startGas:Z(ee,h("Starting gas.")),startTimeSeconds:Z(es,h("Auction start time (seconds since epoch)."))}),h("Status of the perpetual deploy auction."));function ty(e,t){let r=Y(tc,{type:"perpDeployAuctionStatus"});return e.transport.request("info",r,t)}e.s(["perpDexLimits",()=>th],170303);let tm=Z(V({type:Z(M("perpDexLimits"),h("Type of request.")),dex:Z(H(),h("DEX name (empty string for main dex)."))}),h("Request builder deployed perpetual market limits."));function th(e,t,r){let s=Y(tm,{type:"perpDexLimits",...t});return e.transport.request("info",s,r)}e.s(["perpDexs",()=>tv],41501);let tg=Z(V({type:Z(M("perpDexs"),h("Type of request."))}),h("Request all perpetual dexs."));function tv(e,t){let r=Y(tg,{type:"perpDexs"});return e.transport.request("info",r,t)}e.s(["perpDexStatus",()=>tT],552948);let tq=Z(V({type:Z(M("perpDexStatus"),h("Type of request.")),dex:Z(H(),h("Perp dex name of builder-deployed dex market. The empty string represents the first perp dex."))}),h("Request perp DEX status."));function tT(e,t,r){let s=Y(tq,{type:"perpDexStatus",...t});return e.transport.request("info",s,r)}e.s(["PerpsAtOpenInterestCapResponse",()=>tb,"perpsAtOpenInterestCap",()=>tA],901101);let tk=Z(V({type:Z(M("perpsAtOpenInterestCap"),h("Type of request.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request perpetuals at open interest cap.")),tb=Z(P(H()),h("Array of perpetuals at open interest caps."));function tA(e,t,r){let s=t instanceof AbortSignal?{}:t,n=t instanceof AbortSignal?t:r,i=Y(tk,{type:"perpsAtOpenInterestCap",...s});return e.transport.request("info",i,n)}e.s(["PortfolioResponse",()=>tR,"portfolio",()=>tw],286077);let tx=Z(V({type:Z(M("portfolio"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user portfolio.")),tS=Z(V({accountValueHistory:Z(P($([es,ee])),h("History entries for account value as [timestamp, value].")),pnlHistory:Z(P($([es,et])),h("History entries for profit and loss as [timestamp, value].")),vlm:Z(ee,h("Volume metric for the portfolio."))}),h("Portfolio metrics snapshot.")),tR=Z($([$([M("day"),tS]),$([M("week"),tS]),$([M("month"),tS]),$([M("allTime"),tS]),$([M("perpDay"),tS]),$([M("perpWeek"),tS]),$([M("perpMonth"),tS]),$([M("perpAllTime"),tS])]),h("Portfolio metrics grouped by time periods."));function tw(e,t,r){let s=Y(tx,{type:"portfolio",...t});return e.transport.request("info",s,r)}e.s(["predictedFundings",()=>tC],742342);let tD=Z(V({type:Z(M("predictedFundings"),h("Type of request."))}),h("Request predicted funding rates."));function tC(e,t){let r=Y(tD,{type:"predictedFundings"});return e.transport.request("info",r,t)}e.s(["preTransferCheck",()=>tI],668264);let tU=Z(V({type:Z(M("preTransferCheck"),h("Type of request.")),user:Z(ei,h("User address.")),source:Z(ei,h("Source address."))}),h("Request user existence check before transfer."));function tI(e,t,r){let s=Y(tU,{type:"preTransferCheck",...t});return e.transport.request("info",s,r)}e.s(["RecentTradesResponse",()=>tE,"recentTrades",()=>tO],272018);let tP=Z(V({type:Z(M("recentTrades"),h("Type of request.")),coin:Z(H(),h("Asset symbol (e.g., BTC)."))}),h("Request recent trades.")),tE=Z(P(Z(V({coin:Z(H(),h("Asset symbol (e.g., BTC).")),side:Z(W(["B","A"]),h('Trade side ("B" = Bid/Buy, "A" = Ask/Sell).')),px:Z(ee,h("Trade price.")),sz:Z(ee,h("Trade size.")),time:Z(es,h("Trade timestamp (in ms since epoch).")),hash:Z(Z(en,k(66)),h("Transaction hash.")),tid:Z(es,h("Trade ID.")),users:Z($([ei,ei]),h("Addresses of users involved in the trade [Maker, Taker]."))}),h("Trade for a specific asset."))),h("Array of recent trades."));function tO(e,t,r){let s=Y(tP,{type:"recentTrades",...t});return e.transport.request("info",s,r)}e.s(["referral",()=>tj],532578);let tM=Z(V({type:Z(M("referral"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user referral."));function tj(e,t,r){let s=Y(tM,{type:"referral",...t});return e.transport.request("info",s,r)}e.s(["SpotClearinghouseStateResponse",()=>tL,"spotClearinghouseState",()=>tB],732694);let tF=Z(V({type:Z(M("spotClearinghouseState"),h("Type of request.")),user:Z(ei,h("User address.")),dex:Z(N(H()),h("DEX name (empty string for main dex)."))}),h("Request spot clearinghouse state.")),tL=Z(V({balances:Z(P(Z(V({coin:Z(H(),h("Asset symbol.")),token:Z(es,h("Unique identifier for the token.")),total:Z(ee,h("Total balance.")),hold:Z(ee,h("Amount on hold.")),entryNtl:Z(ee,h("Entry notional value."))}),h("Balance for a specific spot token."))),h("Balance for each token.")),evmEscrows:Z(N(P(Z(V({coin:Z(H(),h("Asset symbol.")),token:Z(es,h("Unique identifier for the token.")),total:Z(ee,h("Total balance."))}),h("Escrowed balance for a specific asset.")))),h("Escrowed balances."))}),h("Account summary for spot trading."));function tB(e,t,r){let s=Y(tF,{type:"spotClearinghouseState",...t});return e.transport.request("info",s,r)}e.s(["spotDeployState",()=>t_],676001),e.s(["SpotPairDeployAuctionStatusResponse",()=>tV,"spotPairDeployAuctionStatus",()=>tN],984358);let tz=Z(V({type:Z(M("spotPairDeployAuctionStatus"),h("Type of request."))}),h("Request for the status of the spot deploy auction.")),tV=Z(tf,h("Status of the spot deploy auction."));function tN(e,t){let r=Y(tz,{type:"spotPairDeployAuctionStatus"});return e.transport.request("info",r,t)}let tW=Z(V({type:Z(M("spotDeployState"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request spot deploy state."));function t_(e,t,r){let s=Y(tW,{type:"spotDeployState",...t});return e.transport.request("info",s,r)}e.s(["SpotMetaResponse",()=>t$,"spotMeta",()=>tX],753726);let tH=Z(V({type:Z(M("spotMeta"),h("Type of request."))}),h("Request spot trading metadata.")),t$=Z(V({universe:Z(P(Z(V({tokens:Z(P(es),h("Token indices included in this universe.")),name:Z(H(),h("Name of the universe.")),index:Z(es,h("Unique identifier of the universe.")),isCanonical:Z(E(),h("Indicates if the token is the primary representation in the system."))}),h("Trading universe details."))),h("Trading universes available for spot trading.")),tokens:Z(P(Z(V({name:Z(H(),h("Name of the token.")),szDecimals:Z(es,h("Minimum decimal places for order sizes.")),weiDecimals:Z(es,h("Number of decimals for the token's smallest unit.")),index:Z(es,h("Unique identifier for the token.")),tokenId:Z(en,h("Token ID.")),isCanonical:Z(E(),h("Indicates if the token is the primary representation in the system.")),evmContract:Z(L(V({address:Z(ei,h("Contract address.")),evm_extra_wei_decimals:Z(er,h("Extra decimals in the token's smallest unit."))})),h("EVM contract details.")),fullName:Z(L(H()),h("Full display name of the token.")),deployerTradingFeeShare:Z(ee,h("Deployer trading fee share for the token."))}),h("Spot token details."))),h("Tokens available for spot trading."))}),h("Metadata for spot assets."));function tX(e,t){let r=Y(tH,{type:"spotMeta"});return e.transport.request("info",r,t)}e.s(["spotMetaAndAssetCtxs",()=>tG],769598);let tJ=Z(V({type:Z(M("spotMetaAndAssetCtxs"),h("Type of request."))}),h("Request spot metadata and asset contexts."));function tG(e,t){let r=Y(tJ,{type:"spotMetaAndAssetCtxs"});return e.transport.request("info",r,t)}e.s(["subAccounts",()=>tK],191436);let tQ=Z(V({type:Z(M("subAccounts"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user sub-accounts."));function tK(e,t,r){let s=Y(tQ,{type:"subAccounts",...t});return e.transport.request("info",s,r)}e.s(["subAccounts2",()=>tZ],382488);let tY=Z(V({type:Z(M("subAccounts2"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user sub-accounts."));function tZ(e,t,r){let s=Y(tY,{type:"subAccounts2",...t});return e.transport.request("info",s,r)}e.s(["tokenDetails",()=>t0],135194);let t1=Z(V({type:Z(M("tokenDetails"),h("Type of request.")),tokenId:Z(Z(en,k(34)),h("Token ID."))}),h("Request token details."));function t0(e,t,r){let s=Y(t1,{type:"tokenDetails",...t});return e.transport.request("info",s,r)}e.s(["TwapHistoryResponse",()=>t2,"twapHistory",()=>t5],918934);let t4=Z(V({type:Z(M("twapHistory"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request twap history of a user.")),t2=Z(P(Z(V({time:Z(es,h("Creation time of the history record (in seconds since epoch).")),state:Z(V({coin:Z(H(),h("Asset symbol.")),executedNtl:Z(ee,h("Executed notional value.")),executedSz:Z(ee,h("Executed size.")),minutes:Z(es,h("Duration in minutes.")),randomize:Z(E(),h("Indicates if the TWAP randomizes execution.")),reduceOnly:Z(E(),h("Indicates if the order is reduce-only.")),side:Z(W(["B","A"]),h('Order side ("B" = Bid/Buy, "A" = Ask/Sell).')),sz:Z(ee,h("Order size.")),timestamp:Z(es,h("Start time of the TWAP order (in ms since epoch).")),user:Z(ei,h("User address."))}),h("State of the TWAP order.")),status:Z(Q("status",[V({status:Z(W(["finished","activated","terminated"]),h("Status of the TWAP order."))}),V({status:Z(M("error"),h("Status of the TWAP order.")),description:Z(H(),h("Error message."))})]),h('Current status of the TWAP order.\n- `"finished"`: Fully executed.\n- `"activated"`: Active and executing.\n- `"terminated"`: Terminated.\n- `"error"`: An error occurred.')),twapId:Z(N(es),h("ID of the TWAP."))}),h("TWAP history record."))),h("Array of user's TWAP history."));function t5(e,t,r){let s=Y(t4,{type:"twapHistory",...t});return e.transport.request("info",s,r)}e.s(["txDetails",()=>t9],32237);let t3=Z(V({type:Z(M("txDetails"),h("Type of request.")),hash:Z(Z(en,k(66)),h("Transaction hash."))}),h("Request transaction details by transaction hash."));function t9(e,t,r){let s=Y(t3,{type:"txDetails",...t});return e.transport.request("explorer",s,r)}e.s(["userDetails",()=>t6],40744);let t8=Z(V({type:Z(M("userDetails"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request array of user transaction details."));function t6(e,t,r){let s=Y(t8,{type:"userDetails",...t});return e.transport.request("explorer",s,r)}e.s(["userDexAbstraction",()=>re],581475);let t7=Z(V({type:Z(M("userDexAbstraction"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user referral."));function re(e,t,r){let s=Y(t7,{type:"userDexAbstraction",...t});return e.transport.request("info",s,r)}e.s(["userFees",()=>rr],204053);let rt=Z(V({type:Z(M("userFees"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user fees."));function rr(e,t,r){let s=Y(rt,{type:"userFees",...t});return e.transport.request("info",s,r)}e.s(["UserFillsResponse",()=>rn,"userFills",()=>ri],297516);let rs=Z(V({type:Z(M("userFills"),h("Type of request.")),user:Z(ei,h("User address.")),aggregateByTime:Z(N(E()),h("If true, partial fills are aggregated when a crossing order fills multiple resting orders."))}),h("Request array of user fills.")),rn=Z(P(Z(V({coin:Z(H(),h("Asset symbol.")),px:Z(ee,h("Price.")),sz:Z(ee,h("Size.")),side:Z(W(["B","A"]),h('Order side ("B" = Bid/Buy, "A" = Ask/Sell).')),time:Z(es,h("Timestamp when the trade occurred (in ms since epoch).")),startPosition:Z(et,h("Start position size.")),dir:Z(H(),h("Direction indicator for frontend display.")),closedPnl:Z(et,h("Realized PnL.")),hash:Z(Z(en,k(66)),h("L1 transaction hash.")),oid:Z(es,h("Order ID.")),crossed:Z(E(),h("Indicates if the fill was a taker order.")),fee:Z(et,h("Fee charged or rebate received (negative indicates rebate).")),tid:Z(es,h("Unique transaction identifier for a partial fill of an order.")),cloid:Z(N(Z(en,k(34))),h("Client Order ID.")),liquidation:Z(N(V({liquidatedUser:Z(ei,h("Address of the liquidated user.")),markPx:Z(ee,h("Mark price at the time of liquidation.")),method:Z(W(["market","backstop"]),h("Liquidation method."))})),h("Liquidation details.")),feeToken:Z(H(),h('Token in which the fee is denominated (e.g., "USDC").')),twapId:Z(L(es),h("ID of the TWAP."))}),h("Order fill record."))),h("Array of user trade fills."));function ri(e,t,r){let s=Y(rs,{type:"userFills",...t});return e.transport.request("info",s,r)}e.s(["userFillsByTime",()=>ro],788349);let ra=Z(V({type:Z(M("userFillsByTime"),h("Type of request.")),user:Z(ei,h("User address.")),startTime:Z(es,h("Start time (in ms since epoch).")),endTime:Z(B(es),h("End time (in ms since epoch).")),aggregateByTime:Z(N(E()),h("If true, partial fills are aggregated when a crossing order fills multiple resting orders."))}),h("Request array of user fills by time."));function ro(e,t,r){let s=Y(ra,{type:"userFillsByTime",...t});return e.transport.request("info",s,r)}e.s(["userFunding",()=>rl],331179);let ru=Z(V({type:Z(M("userFunding"),h("Type of request.")),user:Z(ei,h("User address.")),startTime:Z(es,h("Start time (in ms since epoch).")),endTime:Z(B(es),h("End time (in ms since epoch)."))}),h("Request array of user funding ledger updates."));function rl(e,t,r){let s=Y(ru,{type:"userFunding",...t});return e.transport.request("info",s,r)}e.s(["UserNonFundingLedgerUpdatesResponse",()=>rp,"userNonFundingLedgerUpdates",()=>rc],182569);let rd=Z(V({type:Z(M("userNonFundingLedgerUpdates"),h("Type of request.")),user:Z(ei,h("User address.")),startTime:Z(es,h("Start time (in ms since epoch).")),endTime:Z(B(es),h("End time (in ms since epoch)."))}),h("Request user non-funding ledger updates.")),rp=Z(P(Z(V({time:Z(es,h("Timestamp of the update (in ms since epoch).")),hash:Z(Z(en,k(66)),h("L1 transaction hash.")),delta:Z(Q("type",[Z(V({type:Z(M("accountClassTransfer"),h("Update type.")),usdc:Z(ee,h("Amount transferred in USDC.")),toPerp:Z(E(),h("Indicates if the transfer is to the perpetual account."))}),h("Transfer between spot and perpetual accounts.")),Z(V({type:Z(M("deposit"),h("Update type.")),usdc:Z(ee,h("Amount deposited in USDC."))}),h("Deposit to an account.")),Z(V({type:Z(M("internalTransfer"),h("Update type.")),usdc:Z(ee,h("Amount transferred in USDC.")),user:Z(ei,h("Initiator address.")),destination:Z(ei,h("Destination address.")),fee:Z(ee,h("Transfer fee."))}),h("Internal transfer between accounts.")),Z(V({type:Z(M("liquidation"),h("Update type.")),liquidatedNtlPos:Z(ee,h("Total notional value of liquidated positions.")),accountValue:Z(ee,h("Account value at liquidation time.")),leverageType:Z(W(["Cross","Isolated"]),h("Leverage type for liquidated positions.")),liquidatedPositions:Z(P(Z(V({coin:Z(H(),h("Asset symbol of the liquidated position.")),szi:Z(et,h("Signed position size liquidated."))}),h("Liquidated position."))),h("Details of each liquidated position."))}),h("Liquidation event.")),Z(V({type:Z(M("rewardsClaim"),h("Update type.")),amount:Z(ee,h("Amount of rewards claimed.")),token:Z(H(),h("Token symbol."))}),h("Rewards claim event.")),Z(V({type:Z(M("spotTransfer"),h("Update type.")),token:Z(H(),h("Token symbol.")),amount:Z(ee,h("Amount transferred.")),usdcValue:Z(ee,h("Equivalent USDC value.")),user:Z(ei,h("Initiator address.")),destination:Z(ei,h("Destination address.")),fee:Z(ee,h("Transfer fee.")),nativeTokenFee:Z(ee,h("Fee in native token.")),nonce:F(),feeToken:Z(H(),h('Token in which the fee is denominated (e.g., "USDC").'))}),h("Spot transfer between accounts.")),Z(V({type:Z(M("subAccountTransfer"),h("Update type.")),usdc:Z(ee,h("Amount transferred in USDC.")),user:Z(ei,h("Initiator address.")),destination:Z(ei,h("Destination address."))}),h("Transfer between sub-accounts.")),Z(V({type:Z(M("vaultCreate"),h("Update type.")),vault:Z(ei,h("Address of the created vault.")),usdc:Z(ee,h("Initial allocated amount in USDC.")),fee:Z(ee,h("Vault creation fee."))}),h("Vault creation event.")),Z(V({type:Z(M("vaultDeposit"),h("Update type.")),vault:Z(ei,h("Address of the target vault.")),usdc:Z(ee,h("Amount deposited in USDC."))}),h("Vault deposit event.")),Z(V({type:Z(M("vaultDistribution"),h("Update type.")),vault:Z(ei,h("Address of the vault distributing funds.")),usdc:Z(ee,h("Amount distributed in USDC."))}),h("Vault distribution event.")),Z(V({type:Z(M("vaultWithdraw"),h("Update type.")),vault:Z(ei,h("Vault address.")),user:Z(ei,h("Address of the user withdrawing funds.")),requestedUsd:Z(ee,h("Withdrawal request amount in USD.")),commission:Z(ee,h("Withdrawal commission fee.")),closingCost:Z(ee,h("Closing cost associated with positions.")),basis:Z(ee,h("Basis value for withdrawal calculation.")),netWithdrawnUsd:Z(ee,h("Net withdrawn amount in USD after fees and costs."))}),h("Vault withdrawal event.")),Z(V({type:Z(M("withdraw"),h("Update type.")),usdc:Z(ee,h("Amount withdrawn in USDC.")),nonce:Z(es,h("Nonce (timestamp in ms) used to prevent replay attacks.")),fee:Z(ee,h("Withdrawal fee."))}),h("Withdrawal from an account."))]),h("Update details."))}),h("User's non-funding ledger update."))),h("Array of user's non-funding ledger update."));function rc(e,t,r){let s=Y(rd,{type:"userNonFundingLedgerUpdates",...t});return e.transport.request("info",s,r)}e.s(["userRateLimit",()=>ry],291049);let rf=Z(V({type:Z(M("userRateLimit"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user rate limits."));function ry(e,t,r){let s=Y(rf,{type:"userRateLimit",...t});return e.transport.request("info",s,r)}e.s(["userRole",()=>rh],22277);let rm=Z(V({type:Z(M("userRole"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user role."));function rh(e,t,r){let s=Y(rm,{type:"userRole",...t});return e.transport.request("info",s,r)}e.s(["userToMultiSigSigners",()=>rv],886360);let rg=Z(V({type:Z(M("userToMultiSigSigners"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request multi-sig signers for a user."));function rv(e,t,r){let s=Y(rg,{type:"userToMultiSigSigners",...t});return e.transport.request("info",s,r)}e.s(["UserTwapSliceFillsResponse",()=>rT,"userTwapSliceFills",()=>rk],405939);let rq=Z(V({type:Z(M("userTwapSliceFills"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user TWAP slice fills.")),rT=Z(P(Z(V({fill:Z(V({coin:Z(H(),h("Asset symbol.")),px:Z(ee,h("Price.")),sz:Z(ee,h("Size.")),side:Z(W(["B","A"]),h('Order side ("B" = Bid/Buy, "A" = Ask/Sell).')),time:Z(es,h("Timestamp when the trade occurred (in ms since epoch).")),startPosition:Z(et,h("Start position size.")),dir:Z(H(),h("Direction indicator for frontend display.")),closedPnl:Z(et,h("Realized PnL.")),hash:Z(Z(en,k(66)),h("L1 transaction hash.")),oid:Z(es,h("Order ID.")),crossed:Z(E(),h("Indicates if the fill was a taker order.")),fee:Z(et,h("Fee charged or rebate received (negative indicates rebate).")),tid:Z(es,h("Unique transaction identifier for a partial fill of an order.")),feeToken:Z(H(),h('Token in which the fee is denominated (e.g., "USDC").')),twapId:Z(L(es),h("ID of the TWAP."))}),h("TWAP fill record.")),twapId:Z(es,h("ID of the TWAP."))}),h("User twap slice fill."))),h("Array of user's twap slice fills."));function rk(e,t,r){let s=Y(rq,{type:"userTwapSliceFills",...t});return e.transport.request("info",s,r)}e.s(["userTwapSliceFillsByTime",()=>rA],195977);let rb=Z(V({type:Z(M("userTwapSliceFillsByTime"),h("Type of request.")),user:Z(ei,h("User address.")),startTime:Z(es,h("Start time (in ms since epoch).")),endTime:Z(B(es),h("End time (in ms since epoch).")),aggregateByTime:Z(N(E()),h("If true, partial fills are aggregated when a crossing order fills multiple resting orders."))}),h("Request user TWAP slice fills by time."));function rA(e,t,r){let s=Y(rb,{type:"userTwapSliceFillsByTime",...t});return e.transport.request("info",s,r)}e.s(["userVaultEquities",()=>rS],281839);let rx=Z(V({type:Z(M("userVaultEquities"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request user vault deposits."));function rS(e,t,r){let s=Y(rx,{type:"userVaultEquities",...t});return e.transport.request("info",s,r)}e.s(["validatorL1Votes",()=>rw],282535);let rR=Z(V({type:Z(M("validatorL1Votes"),h("Type of request."))}),h("Request validator L1 votes."));function rw(e,t){let r=Y(rR,{type:"validatorL1Votes"});return e.transport.request("info",r,t)}e.s(["validatorSummaries",()=>rC],416618);let rD=Z(V({type:Z(M("validatorSummaries"),h("Type of request."))}),h("Request validator summaries."));function rC(e,t){let r=Y(rD,{type:"validatorSummaries"});return e.transport.request("info",r,t)}e.s(["vaultDetails",()=>rI],943133);let rU=Z(V({type:Z(M("vaultDetails"),h("Type of request.")),vaultAddress:Z(ei,h("Vault address.")),user:Z(B(ei),h("User address."))}),h("Request details of a vault."));function rI(e,t,r){let s=Y(rU,{type:"vaultDetails",...t});return e.transport.request("info",s,r)}e.s(["vaultSummaries",()=>rE],588995);let rP=Z(V({type:Z(M("vaultSummaries"),h("Type of request."))}),h("Request a list of vaults less than 2 hours old."));function rE(e,t){let r=Y(rP,{type:"vaultSummaries"});return e.transport.request("info",r,t)}e.s(["WebData2Response",()=>rM,"webData2",()=>rj],715134);let rO=Z(V({type:Z(M("webData2"),h("Type of request.")),user:Z(ei,h("User address."))}),h("Request comprehensive user and market data.")),rM=Z(V({clearinghouseState:eI,leadingVaults:e9,totalVaultEquity:Z(ee,h("Total equity in vaults.")),openOrders:e$,agentAddress:Z(L(ei),h("Agent address if one exists.")),agentValidUntil:Z(L(es),h("Timestamp until which the agent is valid.")),cumLedger:Z(ee,h("Cumulative ledger value.")),meta:eb,assetCtxs:Z(P(Z(V({prevDayPx:Z(ee,h("Previous day's closing price.")),dayNtlVlm:Z(ee,h("Daily notional volume.")),markPx:Z(ee,h("Mark price.")),midPx:Z(L(ee),h("Mid price.")),funding:Z(et,h("Funding rate.")),openInterest:Z(ee,h("Total open interest.")),premium:Z(L(et),h("Premium price.")),oraclePx:Z(ee,h("Oracle price.")),impactPxs:Z(L(P(H())),h("Array of impact prices.")),dayBaseVlm:Z(ee,h("Daily volume in base currency."))}),h("Context for a specific perpetual asset."))),h("Array of contexts for each perpetual asset.")),serverTime:Z(es,h("Server timestamp (in ms since epoch).")),isVault:Z(E(),h("Whether this account is a vault.")),user:Z(ei,h("User address.")),twapStates:Z(P(Z($([es,Z(V({coin:Z(H(),h("Asset symbol.")),executedNtl:Z(ee,h("Executed notional value.")),executedSz:Z(ee,h("Executed size.")),minutes:Z(es,h("Duration in minutes.")),randomize:Z(E(),h("Indicates if the TWAP randomizes execution.")),reduceOnly:Z(E(),h("Indicates if the order is reduce-only.")),side:Z(W(["B","A"]),h('Order side ("B" = Bid/Buy, "A" = Ask/Sell).')),sz:Z(ee,h("Order size.")),timestamp:Z(es,h("Start time of the TWAP order (in ms since epoch).")),user:Z(ei,h("User address."))}),h("State of the TWAP order."))]),h("TWAP ID and state."))),h("Array of TWAP states.")),spotState:N(tL),spotAssetCtxs:Z(P(Z(V({prevDayPx:Z(ee,h("Previous day's closing price.")),dayNtlVlm:Z(ee,h("Daily notional volume.")),markPx:Z(ee,h("Mark price.")),midPx:Z(L(ee),h("Mid price.")),circulatingSupply:Z(ee,h("Circulating supply.")),coin:Z(H(),h("Asset symbol.")),totalSupply:Z(ee,h("Total supply.")),dayBaseVlm:Z(ee,h("Daily volume in base currency."))}),h("Context for a specific spot asset."))),h("Asset context for each spot asset.")),optOutOfSpotDusting:Z(N(M(!0)),h("Whether the user has opted out of spot dusting.")),perpsAtOpenInterestCap:Z(N(tb),h("Assets currently at their open interest cap."))}),h("Comprehensive user and market data."));function rj(e,t,r){let s=Y(rO,{type:"webData2",...t});return e.transport.request("info",s,r)}}]);
!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="f925bcb4-23e7-5a5f-9855-07e1901020b5")}catch(e){}}();
//# debugId=f925bcb4-23e7-5a5f-9855-07e1901020b5
